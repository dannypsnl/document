<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>More Function - llir/llvm</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "More Function";
    var mkdocs_page_input_path = "user-guide/funcs.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> llir/llvm</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">User Guide</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../basic/">Basic Introduction</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../control/">Control Flow</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">More Function</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#linkage">Linkage</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#variant-argument-aka-vaarg">Variant Argument (a.k.a. VAArg)</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#function-overloading">Function Overloading</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#first-class-functionclosure">First-class Function(Closure)</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#naive-implementation">Naive Implementation</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#improvements">Improvements</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#return-structure">Return Structure</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#add-parameter-attributes">Add parameter attributes</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../types/">High Level Types</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">llir/llvm</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>User Guide &raquo;</li>
        
      
    
    <li>More Function</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="more-function">More Function</h1>
<h3 id="linkage">Linkage</h3>
<p>The following code shows some linkage can use in IR.</p>
<pre><code class="language-go">m := ir.NewModule()

add := m.NewFunc(&quot;add&quot;, types.I64, ir.NewParam(&quot;&quot;, types.I64))
add.Linkage = enum.LinkageInternal
add1 := m.NewFunc(&quot;add1&quot;, types.I64, ir.NewParam(&quot;&quot;, types.I64))
add1.Linkage = enum.LinkageLinkOnce
add2 := m.NewFunc(&quot;add2&quot;, types.I64, ir.NewParam(&quot;&quot;, types.I64))
add2.Linkage = enum.LinkagePrivate
add3 := m.NewFunc(&quot;add3&quot;, types.I64, ir.NewParam(&quot;&quot;, types.I64))
add3.Linkage = enum.LinkageWeak
add4 := m.NewFunc(&quot;add4&quot;, types.I64, ir.NewParam(&quot;&quot;, types.I64))
add4.Linkage = enum.LinkageExternal
</code></pre>
<p>The code would produce:</p>
<pre><code class="language-llvm">declare internal i64 @add(i64)

declare linkonce i64 @add1(i64)

declare private i64 @add2(i64)

declare weak i64 @add3(i64)

declare external i64 @add4(i64)
</code></pre>
<p>For further information about linkage, refer to <a href="https://llvm.org/docs/LangRef.html#linkage-types">LLVM doc</a> and <a href="https://pkg.go.dev/github.com/llir/llvm/ir/enum?tab=doc#Linkage">pkg.go.dev</a>.</p>
<h3 id="variant-argument-aka-vaarg">Variant Argument (a.k.a. VAArg)</h3>
<p>One example of a variadic function is <code>printf</code>. This is how to create a function prototype for <code>printf</code>:</p>
<pre><code class="language-go">m := ir.NewModule()

printf := m.NewFunc(
    &quot;printf&quot;,
    types.I32,
    ir.NewParam(&quot;&quot;, types.NewPointer(types.I8)),
)
printf.Sig.Variadic = true
</code></pre>
<p>The above code would produce the following IR:</p>
<pre><code class="language-llvm">declare i32 @printf(i8*, ...)
</code></pre>
<h3 id="function-overloading">Function Overloading</h3>
<p>There is no overloading in LLVM IR. One solution is to create one function per function signature, where each LLVM IR function would have a unique name (this is why C++ compilers do name mangling).</p>
<h3 id="first-class-functionclosure">First-class Function(Closure)</h3>
<h4 id="naive-implementation">Naive Implementation</h4>
<p>Create a closure(a.k.a. first-class function) requires a place to store captured variables. In LLVM, the best way is create a structure for such case:</p>
<pre><code class="language-go">m := ir.NewModule()

zero := constant.NewInt(types.I32, 0)
one := constant.NewInt(types.I32, 1)

captureStruct := m.NewTypeDef(&quot;id_capture&quot;, types.NewStruct(
    types.I32,
))
captureTyp := types.NewPointer(captureStruct)
idFn := m.NewFunc(&quot;id&quot;, types.I32, ir.NewParam(&quot;capture&quot;, captureTyp))
idB := idFn.NewBlock(&quot;&quot;)
v := idB.NewGetElementPtr(captureStruct, idFn.Params[0], zero, zero)
idB.NewRet(idB.NewLoad(types.I32, v))
idClosureTyp := m.NewTypeDef(&quot;id_closure&quot;, types.NewStruct(
    captureTyp,
    idFn.Type(),
))

mainFn := m.NewFunc(&quot;main&quot;, types.I32)
b := mainFn.NewBlock(&quot;&quot;)
// define a local variable `i`
i := b.NewAlloca(types.I32)
b.NewStore(constant.NewInt(types.I32, 10), i)
// use alloca at here to simplify code, in real case should be `malloc` or `gc_malloc`
captureInstance := b.NewAlloca(captureStruct)
ptrToCapture := b.NewGetElementPtr(captureStruct, captureInstance, zero, zero)
// capture variable
b.NewStore(b.NewLoad(types.I32, i), ptrToCapture)
// prepare closure
idClosure := b.NewAlloca(idClosureTyp)
ptrToCapturePtr := b.NewGetElementPtr(idClosureTyp, idClosure, zero, zero)
b.NewStore(captureInstance, ptrToCapturePtr)
ptrToFuncPtr := b.NewGetElementPtr(idClosureTyp, idClosure, zero, one)
b.NewStore(idFn, ptrToFuncPtr)
// assuming we transfer closure into another context
accessCapture := b.NewGetElementPtr(idClosureTyp, idClosure, zero, zero)
accessFunc := b.NewGetElementPtr(idClosureTyp, idClosure, zero, one)
result := b.NewCall(b.NewLoad(idFn.Type(), accessFunc), b.NewLoad(captureTyp, accessCapture))

printIntegerFormat := m.NewGlobalDef(&quot;tmp&quot;, constant.NewCharArrayFromString(&quot;%d\n&quot;))
pointerToString := b.NewGetElementPtr(types.NewArray(3, types.I8), printIntegerFormat, zero, zero)
// ignore printf
b.NewCall(printf, pointerToString, result)

b.NewRet(constant.NewInt(types.I32, 0))
</code></pre>
<p>This is a huge example, I understand it's hard to read, but concept is clean. It would generate below LLVM IR:</p>
<pre><code class="language-llvm">%id_capture = type { i32 }
%id_closure = type { %id_capture*, i32 (%id_capture*)* }

@tmp = global [3 x i8] c&quot;%d\0A&quot;

declare i32 @printf(i8* %format, ...)

define i32 @id(%id_capture* %capture) {
; &lt;label&gt;:0
    %1 = getelementptr %id_capture, %id_capture* %capture, i32 0, i32 0
    %2 = load i32, i32* %1
    ret i32 %2
}

define i32 @main() {
; &lt;label&gt;:0
    %1 = alloca i32
    store i32 10, i32* %1
    %2 = alloca %id_capture
    %3 = getelementptr %id_capture, %id_capture* %2, i32 0, i32 0
    %4 = load i32, i32* %1
    store i32 %4, i32* %3
    %5 = alloca %id_closure
    %6 = getelementptr %id_closure, %id_closure* %5, i32 0, i32 0
    store %id_capture* %2, %id_capture** %6
    %7 = getelementptr %id_closure, %id_closure* %5, i32 0, i32 1
    store i32 (%id_capture*)* @id, i32 (%id_capture*)** %7
    %8 = getelementptr %id_closure, %id_closure* %5, i32 0, i32 0
    %9 = getelementptr %id_closure, %id_closure* %5, i32 0, i32 1
    %10 = load i32 (%id_capture*)*, i32 (%id_capture*)** %9
    %11 = load %id_capture*, %id_capture** %8
    %12 = call i32 %10(%id_capture* %11)
    %13 = getelementptr [3 x i8], [3 x i8]* @tmp, i32 0, i32 0
    %14 = call i32 (i8*, ...) @printf(i8* %13, i32 %12)
    ret i32 0
}
</code></pre>
<p>Our <code>id</code> function captures an Integer and return it. To reach that <code>id_capture</code> was introduced for storing captured value. For passing whole closure in convenience, <code>id_closure</code> was introduced and stored capture structure and function pointer. When invoke a closure, get captured structure and function pointer from <code>id_closure</code> structure, then apply function with captured structure and additional arguments(if there's any). In this example omit the part about memory management, all structures allocated in the stack, this won't work in most real world case. Must notice this problem.</p>
<h4 id="improvements">Improvements</h4>
<p>The naive implementation is not good enough, we have several ways can improve it, but instead of implementing them I'm going to list what can we do:</p>
<ul>
<li>Laziness function: Arity would be a thing in case</li>
<li>Access cross asynchronous model</li>
<li>If language has copy capture and reference capture, e.g. C++?</li>
<li>What if working with a GC?</li>
</ul>
<h3 id="return-structure">Return Structure</h3>
<p>When meet program that return structure by value, compiler has chance to remove such cloning. That's storing return structure into a reference passed by the caller. Which means, if we get:</p>
<pre><code class="language-c">struct Foo {
    // ...
};

Foo foo() {
    Foo f;
    // ...
    return f;
}
</code></pre>
<p>should compile to:</p>
<pre><code class="language-llvm">define void @foo(%Foo* noalias sret f) {
    // ...
}
</code></pre>
<ul>
<li><code>sret</code> hints this is a return value.</li>
<li><code>noalias</code> hints other arguments won't point to the same place, LLVM optimizer might rely on such fact, so don't add it everywhere.</li>
</ul>
<h4 id="add-parameter-attributes">Add parameter attributes</h4>
<p>Here is example shows how to add parameter attributes:</p>
<pre><code class="language-go">m := ir.NewModule()

fooTyp := m.NewTypeDef(&quot;Foo&quot;, types.NewStruct(
    types.I32,
))
retS := ir.NewParam(&quot;result&quot;, fooTyp)
retS.Attrs = append(retS.Attrs, enum.ParamAttrNoAlias)
retS.Attrs = append(retS.Attrs, enum.ParamAttrSRet)
m.NewFunc(&quot;foo&quot;, types.Void, retS)
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../types/" class="btn btn-neutral float-right" title="High Level Types">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../control/" class="btn btn-neutral" title="Control Flow"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../control/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../types/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
