<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Control Flow - llir/llvm</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../../css/theme.css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "Control Flow";
    var mkdocs_page_input_path = "user-guide/control.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js" defer></script>
  <script src="../../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> llir/llvm</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">User Guide</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../basic/">Basic Introduction</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">Control Flow</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#if">If</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#switch">Switch</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#loop">Loop</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#break">Break</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#do-while">Do While</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#for-loop">For Loop</a>
    </li>
        </ul>
    </li>
    </ul>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../funcs/">More Function</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../types/">High Level Types</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">llir/llvm</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>User Guide &raquo;</li>
        
      
    
    <li>Control Flow</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="control-flow">Control Flow</h1>
<p>Before we start, we need to prepare compile function for something like <strong>expression</strong> and <strong>statement</strong> that not our target.</p>
<pre><code class="language-go">type Expr interface{ isExpr() Expr }
type EConstant interface {
    Expr
    isEConstant() EConstant
}
type EVoid struct{ EConstant }
type EBool struct {
    EConstant
    V bool
}
type EI32 struct {
    EConstant
    V int64
}
type EVariable struct {
    Expr
    Name string
}
type EAdd struct {
    Expr
    Lhs, Rhs Expr
}
type ELessThan struct {
    Expr
    Lhs, Rhs Expr
}
</code></pre>
<p>And compile functions:</p>
<pre><code class="language-go">func compileConstant(e EConstant) constant.Constant {
    switch e := e.(type) {
    case *EI32:
        return constant.NewInt(types.I32, e.V)
    case *EBool:
        // we have no boolean in LLVM IR
        if e.V {
            return constant.NewInt(types.I1, 1)
        } else {
            return constant.NewInt(types.I1, 0)
        }
    case *EVoid:
        return nil
    }
    panic(&quot;unknown expression&quot;)
}

func (ctx *Context) compileExpr(e Expr) value.Value {
    switch e := e.(type) {
    case *EVariable:
        return ctx.lookupVariable(e.Name)
    case *EAdd:
        l, r := ctx.compileExpr(e.Lhs), ctx.compileExpr(e.Rhs)
        return ctx.NewAdd(l, r)
    case *ELessThan:
        l, r := ctx.compileExpr(e.Lhs), ctx.compileExpr(e.Rhs)
        return ctx.NewICmp(enum.IPredSLT, l, r)
    case EConstant:
        return compileConstant(e)
    }
    panic(&quot;unimplemented expression&quot;)
}
</code></pre>
<p><code>EVariable</code> would need context to remember variable's value. Here is the related definition of <code>Context</code>:</p>
<pre><code class="language-go">type Context struct {
    *ir.Block
    parent *Context
    vars   map[string]value.Value
}

func NewContext(b *ir.Block) *Context {
    return &amp;Context{
        Block: b,
        parent:   nil,
        vars:     make(map[string]value.Value),
    }
}

func (c *Context) NewContext(b *ir.Block) *Context {
    ctx := NewContext(b)
    ctx.parent = c
    return ctx
}

func (c Context) lookupVariable(name string) value.Value {
    if v, ok := c.vars[name]; ok {
        return v
    } else if c.parent != nil {
        return c.parent.lookupVariable(name)
    } else {
        fmt.Printf(&quot;variable: `%s`\n&quot;, name)
        panic(&quot;no such variable&quot;)
    }
}
</code></pre>
<p>Finally, we would have some simple statement as placeholder:</p>
<pre><code class="language-go">type Stmt interface{ isStmt() Stmt }
type SDefine struct {
    Stmt
    Name string
    Typ  types.Type
    Expr Expr
}
type SRet struct {
    Stmt
    Val Expr
}
</code></pre>
<p>Then compile:</p>
<pre><code class="language-go">func (ctx *Context) compileStmt(stmt Stmt) {
    if ctx.Parent != nil {
        return
    }
    f := ctx.Parent
    switch s := stmt.(type) {
    case *SDefine:
        v := ctx.NewAlloca(s.Typ)
        ctx.NewStore(ctx.compileExpr(s.Expr), v)
        ctx.vars[s.Name] = v
    case *SRet:
        ctx.NewRet(ctx.compileExpr(s.Val))
    }
}
</code></pre>
<h3 id="if">If</h3>
<p>Since we can let:</p>
<pre><code class="language-go">if condition {
    // A
} else if condition {
    // B
} else {
    // C
}
</code></pre>
<p>became:</p>
<pre><code class="language-go">if condition {
    // A
} else {
    if condition {
        // B
    } else {
        // C
    }
}
</code></pre>
<p>We don't have to convert any <strong>else-if</strong> pattern. Therefore, our <code>If</code> looks like this:</p>
<pre><code class="language-go">type SIf struct {
    Stmt
    Cond Expr
    Then Stmt
    Else Stmt
}
</code></pre>
<p>Then we can get transformers to generate control flow <strong>if</strong>. Using <strong>conditional jump</strong> to generate <strong>if</strong> statement:</p>
<pre><code class="language-go">func (ctx *Context) compileStmt(stmt Stmt) {
    switch s := stmt.(type) {
    case *SIf:
        thenCtx := ctx.NewContext(f.NewBlock(&quot;if.then&quot;))
        thenCtx.compileStmt(s.Then)
        elseB := f.NewBlock(&quot;if.else&quot;)
        ctx.NewContext(elseB).compileStmt(s.Else)
        ctx.NewCondBr(ctx.compileExpr(s.Cond), thenCtx.Block, elseB)
        if !thenCtx.HasTerminator() {
            leaveB := f.NewBlock(&quot;leave.if&quot;)
            thenCtx.NewBr(leaveB)
        }
    }
}
</code></pre>
<p>When generating <strong>if</strong>, the most important thing is <strong>leave block</strong>, when if-then block complete, a jump to skip else block required since there has no <strong>block</strong> in high-level language liked concept in LLVM IR. At the end of a basic-block can be a return and since return would terminate a function, jump after return is a dead code, so we have to check we have to generate <strong>leave block</strong> or not. Here is a small example as usage:</p>
<pre><code class="language-go">f := ir.NewFunc(&quot;foo&quot;, types.Void)
bb := f.NewBlock(&quot;&quot;)

ctx.compileStmt(&amp;SIf{
    Cond: &amp;EBool{V: true},
    Then: &amp;SRet{Val: &amp;EVoid{}},
    Else: &amp;SRet{Val: &amp;EVoid{}},
})
</code></pre>
<p>Finally, we get:</p>
<pre><code class="language-llvm">define void @foo() {
0:
    br i1 true, label %if.then, label %if.else

if.then:
    ret void

if.else:
    ret void
}
</code></pre>
<p>We didn't support else-if directly at here, then we need to know how to handle this via parsing. First, we handle a sequence of <code>if</code> <code>(</code> <code>&lt;expr&gt;</code> <code>)</code> <code>&lt;block&gt;</code>. Ok, we can fill AST with <code>Cond</code> and <code>Then</code>, now we should get a token <code>else</code>, then we expect a <code>&lt;block&gt;</code> or <code>if</code>. When we get a <code>&lt;block&gt;</code> this is a obviously can be use as <code>Else</code>, else a <code>if</code> we keep parsing and use it as <code>Else</code> statement since <code>if</code> for sure is a statement. Of course, with this method, generated IR would have some useless label and jump, but flow analyzing should optimize them later, so it's fine.</p>
<h3 id="switch">Switch</h3>
<p>LLVM has <a href="https://llvm.org/docs/LangRef.html#switch-instruction">switch instruction</a>, hence, we can use it directly.</p>
<pre><code class="language-go">type SSwitch struct {
    Stmt
    Target   Expr
    CaseList []struct {
        EConstant // LLVM IR only takes constant, if you want advanced switch semantic, then you can't directly use this approach
        Stmt
    }
    DefaultCase Stmt
}

func (ctx *Context) compileStmt(stmt Stmt) {
    switch s := stmt.(type) {
    case *SSwitch:
        cases := []*ir.Case{}
        for _, ca := range s.CaseList {
            caseB := f.NewBlock(&quot;switch.case&quot;)
            ctx.NewContext(caseB).compileStmt(ca.Stmt)
            cases = append(cases, ir.NewCase(compileConstant(ca.EConstant), caseB))
        }
        defaultB := f.NewBlock(&quot;switch.default&quot;)
        ctx.NewContext(defaultB).compileStmt(s.DefaultCase)
        ctx.NewSwitch(ctx.compileExpr(s.Target), defaultB, cases...)
    }
}
</code></pre>
<p>For every case, we generate a block, then we can jump to target. Then we put statements into case blocks. Finally, we generate switch for the input block. Notice that, switch instruction of LLVM won't generate <code>break</code> automatically, you can use the same trick in the previous section <strong>If</strong> to generate auto leave block for each case(Go semantic), or record leave block and introduces break statement(C semantic). Now let's test it:</p>
<pre><code class="language-go">f := ir.NewFunc(&quot;foo&quot;, types.Void)
ctx := NewContext(f.NewBlock(&quot;&quot;))

ctx.compileStmt(&amp;SSwitch{
    Target: &amp;EBool{V: true},
    CaseList: []struct {
        EConstant
        Stmt
    }{
        {EConstant: &amp;EBool{V: true}, Stmt: &amp;SRet{Val: &amp;EVoid{}}},
    },
    DefaultCase: &amp;SRet{Val: &amp;EVoid{}},
})
</code></pre>
<p>And output:</p>
<pre><code class="language-llvm">define void @foo() {
0:
    switch i1 true, label %switch.default [
        i1 true, label %switch.case
    ]

switch.case:
    ret void

switch.default:
    ret void
}
</code></pre>
<p>The switch statement in this section is quite naive, for advanced semantic like pattern matching with extraction or where clause, you would need to do more.</p>
<h3 id="loop">Loop</h3>
<h4 id="break">Break</h4>
<p>Break statement needs to extend <code>Context</code>, with a new field called <code>leaveBlock</code>:</p>
<pre><code class="language-go">type Context struct {
    // ...
    leaveBlock *ir.Block
}

func NewContext(b *ir.Block) *Context {
    return &amp;Context{
        // ...
        leaveBlock: nil,
    }
}
</code></pre>
<p>Then it's just a jump:</p>
<pre><code class="language-go">func (ctx *Context) compileStmt(stmt Stmt) {
    switch s := stmt.(type) {
    case *SBreak:
        ctx.NewBr(ctx.leaveBlock)
    }
}
</code></pre>
<p>Remember to update leave block information(and remove it when needed), and continue can be done in the same way.</p>
<h4 id="do-while">Do While</h4>
<p>Do while is the simplest loop structure since it's code structure almost same to the IR structure. Here we go:</p>
<pre><code class="language-go">type SDoWhile struct {
    Stmt
    Cond  Expr
    Block Stmt
}

func (ctx *Context) compileStmt(stmt Stmt) {
    switch s := stmt.(type) {
    case *SDoWhile:
        doCtx := ctx.NewContext(f.NewBlock(&quot;do.while.body&quot;))
        ctx.NewBr(doCtx.Block)
        leaveB := f.NewBlock(&quot;leave.do.while&quot;)
        doCtx.leaveBlock = leaveB
        doCtx.compileStmt(s.Block)
        doCtx.NewCondBr(doCtx.compileExpr(s.Cond), doCtx.Block, leaveB)
    }
}
</code></pre>
<p>Can see that, we jump to do-while body directly. Then we have a leave block, in the end of the do-while body we jump out to leave block or body again depends on condition. Let's test it:</p>
<pre><code class="language-go">f := ir.NewFunc(&quot;foo&quot;, types.Void)
ctx := NewContext(f.NewBlock(&quot;&quot;))

ctx.compileStmt(&amp;SDoWhile{
    Cond: &amp;EBool{V: true},
    Block: &amp;SDefine{
        Stmt: nil,
        Name: &quot;foo&quot;,
        Typ:  types.I32,
        Expr: &amp;EI32{V: 1},
    },
})

f.Blocks[len(f.Blocks)-1].NewRet(nil)
</code></pre>
<p>And output:</p>
<pre><code class="language-llvm">define void @foo() {
0:
    br label %do.while.body

do.while.body:
    %1 = alloca i32
    store i32 1, i32* %1
    br i1 true, label %do.while.body, label %leave.do.while

leave.do.while:
    ret void
}
</code></pre>
<h4 id="for-loop">For Loop</h4>
<p>For-loop would be an interesting case, at here, I only present a for-loop that can only have one initialize variable to reduce complexity, therefore, we have a AST like this:</p>
<pre><code class="language-go">type SForLoop struct {
    Stmt
    InitName string
    InitExpr Expr
    Step     Expr
    Cond     Expr
    Block    Stmt
}
</code></pre>
<p>For example, <code>for (x=0; x=x+1; x&lt;10) {}</code> break down to:</p>
<p>1.<code>InitName</code>: <code>x</code>
 2. <code>InitExpr</code>: <code>0</code>
 3. <code>Step</code>: <code>x+1</code>
 4. <code>Cond</code>: <code>x&lt;10</code>
 5. <code>Block</code>: <code>{}</code></p>
<p>At first view, people might think for-loop is as easy as do-while, but in SSA form, reuse variable in a loop need a new instruction: <a href="https://llvm.org/docs/LangRef.html#i-phi">phi</a>.</p>
<pre><code class="language-go">func (ctx *Context) compileStmt(stmt Stmt) {
    switch s := stmt.(type) {
    case *SForLoop:
        loopCtx := ctx.NewContext(f.NewBlock(&quot;for.loop.body&quot;))
        ctx.NewBr(loopCtx.Block)
        firstAppear := loopCtx.NewPhi(ir.NewIncoming(loopCtx.compileExpr(s.InitExpr), ctx.Block))
        loopCtx.vars[s.InitName] = firstAppear
        step := loopCtx.compileExpr(s.Step)
        firstAppear.Incs = append(firstAppear.Incs, ir.NewIncoming(step, loopCtx.Block))
        loopCtx.vars[s.InitName] = step
        leaveB := f.NewBlock(&quot;leave.for.loop&quot;)
        loopCtx.leaveBlock = leaveB
        loopCtx.compileStmt(s.Block)
        loopCtx.NewCondBr(loopCtx.compileExpr(s.Cond), loopCtx.Block, leaveB)
    }
}
</code></pre>
<ol>
<li>Create a loop body context</li>
<li>jump from the previous block</li>
<li>Put phi into loop body</li>
<li>Phi would have two incoming, first is <code>InitExpr</code>, the second one is <code>Step</code> result.</li>
<li>compile step</li>
<li>compile the conditional branch, jump to loop body or leave block</li>
</ol>
<p>It generates:</p>
<pre><code class="language-llvm">define void @foo() {
0:
    br label %for.loop.body

for.loop.body:
    %1 = phi i32 [ 0, %0 ], [ %2, %for.loop.body ]
    %2 = add i32 %1, 1
    %3 = alloca i32
    store i32 2, i32* %3
    %4 = icmp slt i32 %2, 10
    br i1 %4, label %for.loop.body, label %leave.for.loop

leave.for.loop:
    ret void
}
</code></pre>
<p>In fact, you can also avoid phi, you can make a try as practice.</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../funcs/" class="btn btn-neutral float-right" title="More Function">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../basic/" class="btn btn-neutral" title="Basic Introduction"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../basic/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../funcs/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
