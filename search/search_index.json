{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to llir/llvm Overview Why LLVM? When creating a compiler, a classical design may look like this: hierarchy Source Code Source Code Frontend Frontend Source Code->Frontend Optimizer Optimizer Frontend->Optimizer Backend Backend Optimizer->Backend Machine Code Machine Code Backend->Machine Code This worked quite well in the old days. There was only one input language, and one target machine. Today there exist a lot of target machines to support! And a lot of input languages. Without a shared representation many parts of the compiler would have to be reimplemented for every input/output pair. LLVM offers a solution to this problem by defining such a shared representation, namely LLVM IR. Here is the new design: hierarchy C Frontend C Frontend Optimizer Optimizer C Frontend->Optimizer Fortran Frontend Fortran Frontend Fortran Frontend->Optimizer Ada Frontend Ada Frontend Ada Frontend->Optimizer X86 Backend X86 Backend Optimizer->X86 Backend PowerPC Backend PowerPC Backend Optimizer->PowerPC Backend ARM Backend ARM Backend Optimizer->ARM Backend To write a compiler for a new language, now we only have to focus on our frontend. Similarly, to add support for a new target machine, now we only have to add a new backend. And to improve the code generation of all input/output pairs, now we only have to focus on the middle end optimizer. Thank you, Chris Lattner and all those who have contributed to LLVM. Why llir/llvm? The aim of llir/llvm is to provide a library for interacting with LLVM IR in pure Go. Importantly, llir/llvm is not a binding for LLVM. Therefore, you don't have to compile LLVM (which could take a few hours), and no need to fight with Cgo. Work under a pure Go environment and start your journey. Installation To install llir/llvm , all you need to do is: go get github.com/llir/llvm . Usage According to packages, llir/llvm can be separated into two main parts: asm : This package implements a parser for LLVM IR assembly files. Users can use it for analyzing LLVM IR files. ir : This package declares the types used to represent LLVM IR modules. Users can use it for build LLVM IR modules and operating on them.","title":"Home"},{"location":"#welcome-to-llirllvm","text":"","title":"Welcome to llir/llvm"},{"location":"#overview","text":"","title":"Overview"},{"location":"#why-llvm","text":"When creating a compiler, a classical design may look like this: hierarchy Source Code Source Code Frontend Frontend Source Code->Frontend Optimizer Optimizer Frontend->Optimizer Backend Backend Optimizer->Backend Machine Code Machine Code Backend->Machine Code This worked quite well in the old days. There was only one input language, and one target machine. Today there exist a lot of target machines to support! And a lot of input languages. Without a shared representation many parts of the compiler would have to be reimplemented for every input/output pair. LLVM offers a solution to this problem by defining such a shared representation, namely LLVM IR. Here is the new design: hierarchy C Frontend C Frontend Optimizer Optimizer C Frontend->Optimizer Fortran Frontend Fortran Frontend Fortran Frontend->Optimizer Ada Frontend Ada Frontend Ada Frontend->Optimizer X86 Backend X86 Backend Optimizer->X86 Backend PowerPC Backend PowerPC Backend Optimizer->PowerPC Backend ARM Backend ARM Backend Optimizer->ARM Backend To write a compiler for a new language, now we only have to focus on our frontend. Similarly, to add support for a new target machine, now we only have to add a new backend. And to improve the code generation of all input/output pairs, now we only have to focus on the middle end optimizer. Thank you, Chris Lattner and all those who have contributed to LLVM.","title":"Why LLVM?"},{"location":"#why-llirllvm","text":"The aim of llir/llvm is to provide a library for interacting with LLVM IR in pure Go. Importantly, llir/llvm is not a binding for LLVM. Therefore, you don't have to compile LLVM (which could take a few hours), and no need to fight with Cgo. Work under a pure Go environment and start your journey.","title":"Why llir/llvm?"},{"location":"#installation","text":"To install llir/llvm , all you need to do is: go get github.com/llir/llvm .","title":"Installation"},{"location":"#usage","text":"According to packages, llir/llvm can be separated into two main parts: asm : This package implements a parser for LLVM IR assembly files. Users can use it for analyzing LLVM IR files. ir : This package declares the types used to represent LLVM IR modules. Users can use it for build LLVM IR modules and operating on them.","title":"Usage"},{"location":"user-guide/basic/","text":"Basic Introduction Module An LLVM IR file is a module. A module has many top-level entities: global variables functions types metadata In this basic introduction, we won't dig into metadata, but instead focus on what we can do with global variables, functions, and types. llir/llvm provides package ir for these concepts. Let's see how a C program can be translated into LLVM IR using llir/llvm . C example: int g = 2; int add(int x, int y) { return x + y; } int main() { return add(1, g); } Generate module: package main import ( \"github.com/llir/llvm/ir\" \"github.com/llir/llvm/ir/constant\" \"github.com/llir/llvm/ir/types\" ) func main() { m := ir.NewModule() globalG := m.NewGlobalDef(\"g\", constant.NewInt(types.I32, 2)) funcAdd := m.NewFunc(\"add\", types.I32, ir.NewParam(\"x\", types.I32), ir.NewParam(\"y\", types.I32), ) ab := funcAdd.NewBlock(\"\") ab.NewRet(ab.NewAdd(funcAdd.Params[0], funcAdd.Params[1])) funcMain := m.NewFunc( \"main\", types.I32, ) // omit parameters mb := funcMain.NewBlock(\"\") // llir/llvm would give correct default name for block without name mb.NewRet(mb.NewCall(funcAdd, constant.NewInt(types.I32, 1), mb.NewLoad(types.I32, globalG))) println(m.String()) } Generated IR: @g = global i32 2 define i32 @add(i32 %x, i32 %y) { ; <label>:0 %1 = add i32 %x, %y ret i32 %1 } define i32 @main() { ; <label>:0 %1 = load i32, i32* @g %2 = call i32 @add(i32 1, i32 %1) ret i32 %2 } In this example, we have one global variable and two functions, mapping to C code. Now let's dig into global variables. Global Variable In LLVM IR assembly, the identifier of global variables are prefixed with an @ character. Importantly, global variables are represented in LLVM as pointers, so we have to use load to retreive the value and store to update the value of a global variable. Function Like globals, in LLVM IR assembly the identifier of functions are prefixed with an @ character. Functions are composed by a function prototype prototype and a group of basic blocks. A funciton without basic blocks is a function declaration. The following code would generate a function declaration: m.NewFunc( \"add\", types.I32, ir.NewParam(\"\", types.I32), ir.NewParam(\"\", types.I32), ) Output: declare i32 @add(i32, i32) When we want to bind to existing functions defined in other object files, we would create function declarations. Function Prototype A function prototype or function signature defines the parameters and return type of a function. Basic Block If function is group of basic blocks, then a basic block is a group of instructions. The basic notion behind a basic block is that if any instruction of a basic block is executed, then all instructions of the basic block are executed. In other words, there may be no branching or terminating instruction in the middle of a basic block, and all incoming branches must transfer control flow to the first instruction of the basic block. It is worthwhile to note that most high-level expression would be lowered into a set of instructions, covering one or more basic blocks. llir/llvm provides API to create instructions by a basic block. For further information, refer to the Block API documentation . Instruction An instruction is a set of operations on assembly abstraction level which operate on an abstract machine model, as defined by LLVM. For further information, refer to the Instruction Reference section of the LLVM Language Reference Manual . Type There are many types in LLVM type system, here we focus on how to create a new type. m := ir.NewModule() m.NewTypeDef(\"foo\", types.NewStruct(types.I32)) The above code would produce the following IR: %foo = type { i32 } Which could be mapped to the following C code: typedef struct { int x; } foo; Notice that in LLVM, structure fields have no name. Conclusion We hope that the previous sections have provide enough information about how to get use the documentation to dig into details. We will not dig into the details of each instruction; instead, we aim to provide a whole picture about how to use the library. Therefore, the next section is a list of common high-level concept and how to map them to IR.","title":"Basic Introduction"},{"location":"user-guide/basic/#basic-introduction","text":"","title":"Basic Introduction"},{"location":"user-guide/basic/#module","text":"An LLVM IR file is a module. A module has many top-level entities: global variables functions types metadata In this basic introduction, we won't dig into metadata, but instead focus on what we can do with global variables, functions, and types. llir/llvm provides package ir for these concepts. Let's see how a C program can be translated into LLVM IR using llir/llvm . C example: int g = 2; int add(int x, int y) { return x + y; } int main() { return add(1, g); } Generate module: package main import ( \"github.com/llir/llvm/ir\" \"github.com/llir/llvm/ir/constant\" \"github.com/llir/llvm/ir/types\" ) func main() { m := ir.NewModule() globalG := m.NewGlobalDef(\"g\", constant.NewInt(types.I32, 2)) funcAdd := m.NewFunc(\"add\", types.I32, ir.NewParam(\"x\", types.I32), ir.NewParam(\"y\", types.I32), ) ab := funcAdd.NewBlock(\"\") ab.NewRet(ab.NewAdd(funcAdd.Params[0], funcAdd.Params[1])) funcMain := m.NewFunc( \"main\", types.I32, ) // omit parameters mb := funcMain.NewBlock(\"\") // llir/llvm would give correct default name for block without name mb.NewRet(mb.NewCall(funcAdd, constant.NewInt(types.I32, 1), mb.NewLoad(types.I32, globalG))) println(m.String()) } Generated IR: @g = global i32 2 define i32 @add(i32 %x, i32 %y) { ; <label>:0 %1 = add i32 %x, %y ret i32 %1 } define i32 @main() { ; <label>:0 %1 = load i32, i32* @g %2 = call i32 @add(i32 1, i32 %1) ret i32 %2 } In this example, we have one global variable and two functions, mapping to C code. Now let's dig into global variables.","title":"Module"},{"location":"user-guide/basic/#global-variable","text":"In LLVM IR assembly, the identifier of global variables are prefixed with an @ character. Importantly, global variables are represented in LLVM as pointers, so we have to use load to retreive the value and store to update the value of a global variable.","title":"Global Variable"},{"location":"user-guide/basic/#function","text":"Like globals, in LLVM IR assembly the identifier of functions are prefixed with an @ character. Functions are composed by a function prototype prototype and a group of basic blocks. A funciton without basic blocks is a function declaration. The following code would generate a function declaration: m.NewFunc( \"add\", types.I32, ir.NewParam(\"\", types.I32), ir.NewParam(\"\", types.I32), ) Output: declare i32 @add(i32, i32) When we want to bind to existing functions defined in other object files, we would create function declarations.","title":"Function"},{"location":"user-guide/basic/#function-prototype","text":"A function prototype or function signature defines the parameters and return type of a function.","title":"Function Prototype"},{"location":"user-guide/basic/#basic-block","text":"If function is group of basic blocks, then a basic block is a group of instructions. The basic notion behind a basic block is that if any instruction of a basic block is executed, then all instructions of the basic block are executed. In other words, there may be no branching or terminating instruction in the middle of a basic block, and all incoming branches must transfer control flow to the first instruction of the basic block. It is worthwhile to note that most high-level expression would be lowered into a set of instructions, covering one or more basic blocks. llir/llvm provides API to create instructions by a basic block. For further information, refer to the Block API documentation .","title":"Basic Block"},{"location":"user-guide/basic/#instruction","text":"An instruction is a set of operations on assembly abstraction level which operate on an abstract machine model, as defined by LLVM. For further information, refer to the Instruction Reference section of the LLVM Language Reference Manual .","title":"Instruction"},{"location":"user-guide/basic/#type","text":"There are many types in LLVM type system, here we focus on how to create a new type. m := ir.NewModule() m.NewTypeDef(\"foo\", types.NewStruct(types.I32)) The above code would produce the following IR: %foo = type { i32 } Which could be mapped to the following C code: typedef struct { int x; } foo; Notice that in LLVM, structure fields have no name.","title":"Type"},{"location":"user-guide/basic/#conclusion","text":"We hope that the previous sections have provide enough information about how to get use the documentation to dig into details. We will not dig into the details of each instruction; instead, we aim to provide a whole picture about how to use the library. Therefore, the next section is a list of common high-level concept and how to map them to IR.","title":"Conclusion"},{"location":"user-guide/control/","text":"Control Flow If Since we can let: if condition { // A } else if condition { // B } else { // C } became: if condition { // A } else { if condition { // B } else { // C } } We don't have to convert any else-if pattern. Therefore, our source AST looks like this: type Expr interface{ isExpr() Expr } type EVoid struct{ Expr } type EBool struct { Expr V bool } type Stmt interface{ isStmt() Stmt } type SIf struct { Stmt Cond Expr Then Stmt Else Stmt } type SRet struct { Stmt Val Expr } First, we limit expression to EBool and EVoid , and statement to SIf and SRet , to get a simple subset to focus on our purpose. Then we can get transformers to generate control flow if . generate value for expression, 0 for false , non 0 for true func compileExpr(b *ir.Block, e Expr) value.Value { switch e := e.(type) { case *EBool: if e.V { return constant.NewInt(types.I1, 1) } else { return constant.NewInt(types.I1, 0) } case *EVoid: return nil } panic(\"unknown expression\") } use conditional jump to generate if statement func compileStmt(f *ir.Func, bb *ir.Block, stmt Stmt) { switch s := stmt.(type) { case *SIf: thenB := f.NewBlock(\"\") compileStmt(f, thenB, s.Then) elseB := f.NewBlock(\"\") compileStmt(f, elseB, s.Else) bb.NewCondBr(compileExpr(bb, s.Cond), thenB, elseB) if thenB.Term == nil { leaveB := f.NewBlock(\"\") thenB.NewBr(leaveB) } case *SRet: bb.NewRet(compileExpr(bb, s.Val)) } } When generating if , the most important thing is leave block , when if-then block complete, a jump to skip else block required since there has no block in high-level language liked concept in LLVM IR. At the end of a basic-block can be a return and since return would terminate a function, jump after return is a dead code, so we have to check we have to generate leave block or not. Here is a small example as usage: f := ir.NewFunc(\"foo\", types.Void) bb := f.NewBlock(\"\") compileStmt(f, bb, &SIf{ Cond: &EBool{V: true}, Then: nil, Else: &SRet{Val: &EVoid{}}, }) // whatever what we did in compileStmt, we use convention that a block leave in the end is empty. f.Blocks[len(f.Blocks)-1].NewRet(nil) We didn't support else-if directly at here, then we need to know how to handle this via parsing. First, we handle a sequence of if ( <expr> ) <block> . Ok, we can fill AST with Cond and Then , now we should get a token else , then we expect a <block> or if . When we get a <block> this is a obviously can be use as Else , else a if we keep parsing and use it as Else statement since if for sure is a statement. Of course, with this method, generated IR would have some useless label and jump, but flow analyzing should optimized them later, so it's fine.","title":"Control Flow"},{"location":"user-guide/control/#control-flow","text":"","title":"Control Flow"},{"location":"user-guide/control/#if","text":"Since we can let: if condition { // A } else if condition { // B } else { // C } became: if condition { // A } else { if condition { // B } else { // C } } We don't have to convert any else-if pattern. Therefore, our source AST looks like this: type Expr interface{ isExpr() Expr } type EVoid struct{ Expr } type EBool struct { Expr V bool } type Stmt interface{ isStmt() Stmt } type SIf struct { Stmt Cond Expr Then Stmt Else Stmt } type SRet struct { Stmt Val Expr } First, we limit expression to EBool and EVoid , and statement to SIf and SRet , to get a simple subset to focus on our purpose. Then we can get transformers to generate control flow if . generate value for expression, 0 for false , non 0 for true func compileExpr(b *ir.Block, e Expr) value.Value { switch e := e.(type) { case *EBool: if e.V { return constant.NewInt(types.I1, 1) } else { return constant.NewInt(types.I1, 0) } case *EVoid: return nil } panic(\"unknown expression\") } use conditional jump to generate if statement func compileStmt(f *ir.Func, bb *ir.Block, stmt Stmt) { switch s := stmt.(type) { case *SIf: thenB := f.NewBlock(\"\") compileStmt(f, thenB, s.Then) elseB := f.NewBlock(\"\") compileStmt(f, elseB, s.Else) bb.NewCondBr(compileExpr(bb, s.Cond), thenB, elseB) if thenB.Term == nil { leaveB := f.NewBlock(\"\") thenB.NewBr(leaveB) } case *SRet: bb.NewRet(compileExpr(bb, s.Val)) } } When generating if , the most important thing is leave block , when if-then block complete, a jump to skip else block required since there has no block in high-level language liked concept in LLVM IR. At the end of a basic-block can be a return and since return would terminate a function, jump after return is a dead code, so we have to check we have to generate leave block or not. Here is a small example as usage: f := ir.NewFunc(\"foo\", types.Void) bb := f.NewBlock(\"\") compileStmt(f, bb, &SIf{ Cond: &EBool{V: true}, Then: nil, Else: &SRet{Val: &EVoid{}}, }) // whatever what we did in compileStmt, we use convention that a block leave in the end is empty. f.Blocks[len(f.Blocks)-1].NewRet(nil) We didn't support else-if directly at here, then we need to know how to handle this via parsing. First, we handle a sequence of if ( <expr> ) <block> . Ok, we can fill AST with Cond and Then , now we should get a token else , then we expect a <block> or if . When we get a <block> this is a obviously can be use as Else , else a if we keep parsing and use it as Else statement since if for sure is a statement. Of course, with this method, generated IR would have some useless label and jump, but flow analyzing should optimized them later, so it's fine.","title":"If"},{"location":"user-guide/funcs/","text":"More Function Linkage The following code shows some linkage can use in IR. m := ir.NewModule() add := m.NewFunc(\"add\", types.I64, ir.NewParam(\"\", types.I64)) add.Linkage = enum.LinkageInternal add1 := m.NewFunc(\"add1\", types.I64, ir.NewParam(\"\", types.I64)) add1.Linkage = enum.LinkageLinkOnce add2 := m.NewFunc(\"add2\", types.I64, ir.NewParam(\"\", types.I64)) add2.Linkage = enum.LinkagePrivate add3 := m.NewFunc(\"add3\", types.I64, ir.NewParam(\"\", types.I64)) add3.Linkage = enum.LinkageWeak add4 := m.NewFunc(\"add4\", types.I64, ir.NewParam(\"\", types.I64)) add4.Linkage = enum.LinkageExternal The code would produce: declare internal i64 @add(i64) declare linkonce i64 @add1(i64) declare private i64 @add2(i64) declare weak i64 @add3(i64) declare external i64 @add4(i64) For further information about linkage, refer to LLVM doc and pkg.go.dev . Variant Argument (a.k.a. VAArg) One example of a variadic function is printf . This is how to create a function prototype for printf : m := ir.NewModule() printf := m.NewFunc( \"printf\", types.I32, ir.NewParam(\"\", types.NewPointer(types.I8)), ) printf.Sig.Variadic = true The above code would produce the following IR: declare i32 @printf(i8*, ...) Function Overloading There is no overloading in LLVM IR. One solution is to create one function per function signature, where each LLVM IR function would have a unique name (this is why C++ compilers do name mangling). First-class Function(Closure) Naive Implementation Create a closure(a.k.a. first-class function) requires a place to store captured variables. In LLVM, the best way is create a structure for such case: m := ir.NewModule() zero := constant.NewInt(types.I32, 0) one := constant.NewInt(types.I32, 1) captureStruct := m.NewTypeDef(\"id_capture\", types.NewStruct( types.I32, )) captureTyp := types.NewPointer(captureStruct) idFn := m.NewFunc(\"id\", types.I32, ir.NewParam(\"capture\", captureTyp)) idB := idFn.NewBlock(\"\") v := idB.NewGetElementPtr(captureStruct, idFn.Params[0], zero, zero) idB.NewRet(idB.NewLoad(types.I32, v)) idClosureTyp := m.NewTypeDef(\"id_closure\", types.NewStruct( captureTyp, idFn.Type(), )) mainFn := m.NewFunc(\"main\", types.I32) b := mainFn.NewBlock(\"\") // define a local variable `i` i := b.NewAlloca(types.I32) b.NewStore(constant.NewInt(types.I32, 10), i) // use alloca at here to simplify code, in real case should be `malloc` or `gc_malloc` captureInstance := b.NewAlloca(captureStruct) ptrToCapture := b.NewGetElementPtr(captureStruct, captureInstance, zero, zero) // capture variable b.NewStore(b.NewLoad(types.I32, i), ptrToCapture) // prepare closure idClosure := b.NewAlloca(idClosureTyp) ptrToCapturePtr := b.NewGetElementPtr(idClosureTyp, idClosure, zero, zero) b.NewStore(captureInstance, ptrToCapturePtr) ptrToFuncPtr := b.NewGetElementPtr(idClosureTyp, idClosure, zero, one) b.NewStore(idFn, ptrToFuncPtr) // assuming we transfer closure into another context accessCapture := b.NewGetElementPtr(idClosureTyp, idClosure, zero, zero) accessFunc := b.NewGetElementPtr(idClosureTyp, idClosure, zero, one) result := b.NewCall(b.NewLoad(idFn.Type(), accessFunc), b.NewLoad(captureTyp, accessCapture)) printIntegerFormat := m.NewGlobalDef(\"tmp\", constant.NewCharArrayFromString(\"%d\\n\")) pointerToString := b.NewGetElementPtr(types.NewArray(3, types.I8), printIntegerFormat, zero, zero) // ignore printf b.NewCall(printf, pointerToString, result) b.NewRet(constant.NewInt(types.I32, 0)) This is a huge example, I understand it's hard to read, but concept is clean. It would generate below LLVM IR: %id_capture = type { i32 } %id_closure = type { %id_capture*, i32 (%id_capture*)* } @tmp = global [3 x i8] c\"%d\\0A\" declare i32 @printf(i8* %format, ...) define i32 @id(%id_capture* %capture) { ; <label>:0 %1 = getelementptr %id_capture, %id_capture* %capture, i32 0, i32 0 %2 = load i32, i32* %1 ret i32 %2 } define i32 @main() { ; <label>:0 %1 = alloca i32 store i32 10, i32* %1 %2 = alloca %id_capture %3 = getelementptr %id_capture, %id_capture* %2, i32 0, i32 0 %4 = load i32, i32* %1 store i32 %4, i32* %3 %5 = alloca %id_closure %6 = getelementptr %id_closure, %id_closure* %5, i32 0, i32 0 store %id_capture* %2, %id_capture** %6 %7 = getelementptr %id_closure, %id_closure* %5, i32 0, i32 1 store i32 (%id_capture*)* @id, i32 (%id_capture*)** %7 %8 = getelementptr %id_closure, %id_closure* %5, i32 0, i32 0 %9 = getelementptr %id_closure, %id_closure* %5, i32 0, i32 1 %10 = load i32 (%id_capture*)*, i32 (%id_capture*)** %9 %11 = load %id_capture*, %id_capture** %8 %12 = call i32 %10(%id_capture* %11) %13 = getelementptr [3 x i8], [3 x i8]* @tmp, i32 0, i32 0 %14 = call i32 (i8*, ...) @printf(i8* %13, i32 %12) ret i32 0 } Our id function captures an Integer and return it. To reach that id_capture was introduced for storing captured value. For passing whole closure in convenience, id_closure was introduced and stored capture structure and function pointer. When invoke a closure, get captured structure and function pointer from id_closure structure, then apply function with captured structure and additional arguments(if there's any). In this example omit the part about memory management, all structures allocated in the stack, this won't work in most real world case. Must notice this problem. Improvements The naive implementation is not good enough, we have several ways can improve it, but instead of implementing them I'm going to list what can we do: Laziness function: Arity would be a thing in case Access cross asynchronous model If language has copy capture and reference capture, e.g. C++? What if working with a GC? Return Structure When meet program that return structure by value, compiler has chance to remove such cloning. That's storing return structure into a reference passed by the caller. Which means, if we get: struct Foo { // ... }; Foo foo() { Foo f; // ... return f; } should compile to: define void @foo(%Foo* noalias sret f) { // ... } sret hints this is a return value. noalias hints other arguments won't point to the same place, LLVM optimizer might rely on such fact, so don't add it everywhere. Add parameter attributes Here is example shows how to add parameter attributes: m := ir.NewModule() fooTyp := m.NewTypeDef(\"Foo\", types.NewStruct( types.I32, )) retS := ir.NewParam(\"result\", fooTyp) retS.Attrs = append(retS.Attrs, enum.ParamAttrNoAlias) retS.Attrs = append(retS.Attrs, enum.ParamAttrSRet) m.NewFunc(\"foo\", types.Void, retS)","title":"More Function"},{"location":"user-guide/funcs/#more-function","text":"","title":"More Function"},{"location":"user-guide/funcs/#linkage","text":"The following code shows some linkage can use in IR. m := ir.NewModule() add := m.NewFunc(\"add\", types.I64, ir.NewParam(\"\", types.I64)) add.Linkage = enum.LinkageInternal add1 := m.NewFunc(\"add1\", types.I64, ir.NewParam(\"\", types.I64)) add1.Linkage = enum.LinkageLinkOnce add2 := m.NewFunc(\"add2\", types.I64, ir.NewParam(\"\", types.I64)) add2.Linkage = enum.LinkagePrivate add3 := m.NewFunc(\"add3\", types.I64, ir.NewParam(\"\", types.I64)) add3.Linkage = enum.LinkageWeak add4 := m.NewFunc(\"add4\", types.I64, ir.NewParam(\"\", types.I64)) add4.Linkage = enum.LinkageExternal The code would produce: declare internal i64 @add(i64) declare linkonce i64 @add1(i64) declare private i64 @add2(i64) declare weak i64 @add3(i64) declare external i64 @add4(i64) For further information about linkage, refer to LLVM doc and pkg.go.dev .","title":"Linkage"},{"location":"user-guide/funcs/#variant-argument-aka-vaarg","text":"One example of a variadic function is printf . This is how to create a function prototype for printf : m := ir.NewModule() printf := m.NewFunc( \"printf\", types.I32, ir.NewParam(\"\", types.NewPointer(types.I8)), ) printf.Sig.Variadic = true The above code would produce the following IR: declare i32 @printf(i8*, ...)","title":"Variant Argument (a.k.a. VAArg)"},{"location":"user-guide/funcs/#function-overloading","text":"There is no overloading in LLVM IR. One solution is to create one function per function signature, where each LLVM IR function would have a unique name (this is why C++ compilers do name mangling).","title":"Function Overloading"},{"location":"user-guide/funcs/#first-class-functionclosure","text":"","title":"First-class Function(Closure)"},{"location":"user-guide/funcs/#naive-implementation","text":"Create a closure(a.k.a. first-class function) requires a place to store captured variables. In LLVM, the best way is create a structure for such case: m := ir.NewModule() zero := constant.NewInt(types.I32, 0) one := constant.NewInt(types.I32, 1) captureStruct := m.NewTypeDef(\"id_capture\", types.NewStruct( types.I32, )) captureTyp := types.NewPointer(captureStruct) idFn := m.NewFunc(\"id\", types.I32, ir.NewParam(\"capture\", captureTyp)) idB := idFn.NewBlock(\"\") v := idB.NewGetElementPtr(captureStruct, idFn.Params[0], zero, zero) idB.NewRet(idB.NewLoad(types.I32, v)) idClosureTyp := m.NewTypeDef(\"id_closure\", types.NewStruct( captureTyp, idFn.Type(), )) mainFn := m.NewFunc(\"main\", types.I32) b := mainFn.NewBlock(\"\") // define a local variable `i` i := b.NewAlloca(types.I32) b.NewStore(constant.NewInt(types.I32, 10), i) // use alloca at here to simplify code, in real case should be `malloc` or `gc_malloc` captureInstance := b.NewAlloca(captureStruct) ptrToCapture := b.NewGetElementPtr(captureStruct, captureInstance, zero, zero) // capture variable b.NewStore(b.NewLoad(types.I32, i), ptrToCapture) // prepare closure idClosure := b.NewAlloca(idClosureTyp) ptrToCapturePtr := b.NewGetElementPtr(idClosureTyp, idClosure, zero, zero) b.NewStore(captureInstance, ptrToCapturePtr) ptrToFuncPtr := b.NewGetElementPtr(idClosureTyp, idClosure, zero, one) b.NewStore(idFn, ptrToFuncPtr) // assuming we transfer closure into another context accessCapture := b.NewGetElementPtr(idClosureTyp, idClosure, zero, zero) accessFunc := b.NewGetElementPtr(idClosureTyp, idClosure, zero, one) result := b.NewCall(b.NewLoad(idFn.Type(), accessFunc), b.NewLoad(captureTyp, accessCapture)) printIntegerFormat := m.NewGlobalDef(\"tmp\", constant.NewCharArrayFromString(\"%d\\n\")) pointerToString := b.NewGetElementPtr(types.NewArray(3, types.I8), printIntegerFormat, zero, zero) // ignore printf b.NewCall(printf, pointerToString, result) b.NewRet(constant.NewInt(types.I32, 0)) This is a huge example, I understand it's hard to read, but concept is clean. It would generate below LLVM IR: %id_capture = type { i32 } %id_closure = type { %id_capture*, i32 (%id_capture*)* } @tmp = global [3 x i8] c\"%d\\0A\" declare i32 @printf(i8* %format, ...) define i32 @id(%id_capture* %capture) { ; <label>:0 %1 = getelementptr %id_capture, %id_capture* %capture, i32 0, i32 0 %2 = load i32, i32* %1 ret i32 %2 } define i32 @main() { ; <label>:0 %1 = alloca i32 store i32 10, i32* %1 %2 = alloca %id_capture %3 = getelementptr %id_capture, %id_capture* %2, i32 0, i32 0 %4 = load i32, i32* %1 store i32 %4, i32* %3 %5 = alloca %id_closure %6 = getelementptr %id_closure, %id_closure* %5, i32 0, i32 0 store %id_capture* %2, %id_capture** %6 %7 = getelementptr %id_closure, %id_closure* %5, i32 0, i32 1 store i32 (%id_capture*)* @id, i32 (%id_capture*)** %7 %8 = getelementptr %id_closure, %id_closure* %5, i32 0, i32 0 %9 = getelementptr %id_closure, %id_closure* %5, i32 0, i32 1 %10 = load i32 (%id_capture*)*, i32 (%id_capture*)** %9 %11 = load %id_capture*, %id_capture** %8 %12 = call i32 %10(%id_capture* %11) %13 = getelementptr [3 x i8], [3 x i8]* @tmp, i32 0, i32 0 %14 = call i32 (i8*, ...) @printf(i8* %13, i32 %12) ret i32 0 } Our id function captures an Integer and return it. To reach that id_capture was introduced for storing captured value. For passing whole closure in convenience, id_closure was introduced and stored capture structure and function pointer. When invoke a closure, get captured structure and function pointer from id_closure structure, then apply function with captured structure and additional arguments(if there's any). In this example omit the part about memory management, all structures allocated in the stack, this won't work in most real world case. Must notice this problem.","title":"Naive Implementation"},{"location":"user-guide/funcs/#improvements","text":"The naive implementation is not good enough, we have several ways can improve it, but instead of implementing them I'm going to list what can we do: Laziness function: Arity would be a thing in case Access cross asynchronous model If language has copy capture and reference capture, e.g. C++? What if working with a GC?","title":"Improvements"},{"location":"user-guide/funcs/#return-structure","text":"When meet program that return structure by value, compiler has chance to remove such cloning. That's storing return structure into a reference passed by the caller. Which means, if we get: struct Foo { // ... }; Foo foo() { Foo f; // ... return f; } should compile to: define void @foo(%Foo* noalias sret f) { // ... } sret hints this is a return value. noalias hints other arguments won't point to the same place, LLVM optimizer might rely on such fact, so don't add it everywhere.","title":"Return Structure"},{"location":"user-guide/funcs/#add-parameter-attributes","text":"Here is example shows how to add parameter attributes: m := ir.NewModule() fooTyp := m.NewTypeDef(\"Foo\", types.NewStruct( types.I32, )) retS := ir.NewParam(\"result\", fooTyp) retS.Attrs = append(retS.Attrs, enum.ParamAttrNoAlias) retS.Attrs = append(retS.Attrs, enum.ParamAttrSRet) m.NewFunc(\"foo\", types.Void, retS)","title":"Add parameter attributes"},{"location":"user-guide/types/","text":"High level types Structure Structure is quite common and basic type in programming language. Here focus on how to create an equal LLVM mapping for structure. LLVM has the concept about structure type, but structure type in LLVM didn't have field name, how to get/set fields of structure would be a thing. Let's assume a structure: foo has a field named x with type i32 . Below code shows how to access x . zero := constant.NewInt(types.I32, 0) m := ir.NewModule() foo := m.NewTypeDef(\"foo\", types.NewStruct(types.I32)) main := m.NewFunc(\"main\", types.I32) b := main.NewBlock(\"\") fooInstance := b.NewAlloca(foo) fieldX := b.NewGetElementPtr(foo, fooInstance, zero, zero) // now `fieldX` is a pointer to field `x` of `foo`. b.NewStore(constant.NewInt(types.I32, 10), fieldX) b.NewLoad(types.I32, fieldX) b.NewRet(zero) Get element pointer(a.k.a. GEP) is the point here. It computes a pointer to any structure member with no overhead. Then load and store can work on it. To get more information about GEP can goto Lang Ref . Algebra Data Type Algebra data type is a common concept in functional programming language. For example, Haskell can write: data Expr = EInt Int | EBool Bool | EString String How to express such concept in LLVM? The idea was selecting the biggest size in all variants and use it as the size of this type. Do bitcast when need to access the actual value. Here is the code: mod := ir.NewModule() typeExpr := mod.NewTypeDef(\"Expr\", types.NewStruct( types.I8, types.NewArray(8, types.I8), )) // variant tag 0 typeExprInt := mod.NewTypeDef(\"EInt\", types.NewStruct( types.I8, types.I32, )) // variant tag 1 mod.NewTypeDef(\"EBool\", types.NewStruct( types.I8, types.I1, )) // variant tag 2 mod.NewTypeDef(\"EString\", types.NewStruct( types.I8, types.NewPointer(types.I8), )) main := mod.NewFunc( \"main\", types.I32, ) b := main.NewBlock(\"\") exprInstance := b.NewAlloca(typeExpr) exprTag := b.NewGetElementPtr(typeExpr, exprInstance, constI32(0), constI32(0)) // set tag to 0 b.NewStore(constI8(0), exprTag) exprIntInstance := b.NewBitCast(exprInstance, types.NewPointer(typeExprInt)) exprIntValue := b.NewGetElementPtr(typeExprInt, exprIntInstance, constI32(0), constI32(1)) b.NewStore(constI32(2), exprIntValue) b.NewRet(constI32(0)) These code produce: %Expr = type { i8, [8 x i8] } %EInt = type { i8, i32 } %EBool = type { i8, i1 } %EString = type { i8, i8* } define i32 @main() { ; <label>:0 %1 = alloca %Expr %2 = getelementptr %Expr, %Expr* %1, i32 0, i32 0 store i8 0, i8* %2 %3 = bitcast %Expr* %1 to %EInt* %4 = getelementptr %EInt, %EInt* %3, i32 0, i32 1 store i32 2, i32* %4 ret i32 0 } tag in each variant is important, for example, pattern matching in Haskell looks like: case expr of EInt i -> \"int\" EBool b -> \"bool\" EString s -> \"string\" case expression would need tag to distinguish variant.","title":"High Level Types"},{"location":"user-guide/types/#high-level-types","text":"","title":"High level types"},{"location":"user-guide/types/#structure","text":"Structure is quite common and basic type in programming language. Here focus on how to create an equal LLVM mapping for structure. LLVM has the concept about structure type, but structure type in LLVM didn't have field name, how to get/set fields of structure would be a thing. Let's assume a structure: foo has a field named x with type i32 . Below code shows how to access x . zero := constant.NewInt(types.I32, 0) m := ir.NewModule() foo := m.NewTypeDef(\"foo\", types.NewStruct(types.I32)) main := m.NewFunc(\"main\", types.I32) b := main.NewBlock(\"\") fooInstance := b.NewAlloca(foo) fieldX := b.NewGetElementPtr(foo, fooInstance, zero, zero) // now `fieldX` is a pointer to field `x` of `foo`. b.NewStore(constant.NewInt(types.I32, 10), fieldX) b.NewLoad(types.I32, fieldX) b.NewRet(zero) Get element pointer(a.k.a. GEP) is the point here. It computes a pointer to any structure member with no overhead. Then load and store can work on it. To get more information about GEP can goto Lang Ref .","title":"Structure"},{"location":"user-guide/types/#algebra-data-type","text":"Algebra data type is a common concept in functional programming language. For example, Haskell can write: data Expr = EInt Int | EBool Bool | EString String How to express such concept in LLVM? The idea was selecting the biggest size in all variants and use it as the size of this type. Do bitcast when need to access the actual value. Here is the code: mod := ir.NewModule() typeExpr := mod.NewTypeDef(\"Expr\", types.NewStruct( types.I8, types.NewArray(8, types.I8), )) // variant tag 0 typeExprInt := mod.NewTypeDef(\"EInt\", types.NewStruct( types.I8, types.I32, )) // variant tag 1 mod.NewTypeDef(\"EBool\", types.NewStruct( types.I8, types.I1, )) // variant tag 2 mod.NewTypeDef(\"EString\", types.NewStruct( types.I8, types.NewPointer(types.I8), )) main := mod.NewFunc( \"main\", types.I32, ) b := main.NewBlock(\"\") exprInstance := b.NewAlloca(typeExpr) exprTag := b.NewGetElementPtr(typeExpr, exprInstance, constI32(0), constI32(0)) // set tag to 0 b.NewStore(constI8(0), exprTag) exprIntInstance := b.NewBitCast(exprInstance, types.NewPointer(typeExprInt)) exprIntValue := b.NewGetElementPtr(typeExprInt, exprIntInstance, constI32(0), constI32(1)) b.NewStore(constI32(2), exprIntValue) b.NewRet(constI32(0)) These code produce: %Expr = type { i8, [8 x i8] } %EInt = type { i8, i32 } %EBool = type { i8, i1 } %EString = type { i8, i8* } define i32 @main() { ; <label>:0 %1 = alloca %Expr %2 = getelementptr %Expr, %Expr* %1, i32 0, i32 0 store i8 0, i8* %2 %3 = bitcast %Expr* %1 to %EInt* %4 = getelementptr %EInt, %EInt* %3, i32 0, i32 1 store i32 2, i32* %4 ret i32 0 } tag in each variant is important, for example, pattern matching in Haskell looks like: case expr of EInt i -> \"int\" EBool b -> \"bool\" EString s -> \"string\" case expression would need tag to distinguish variant.","title":"Algebra Data Type"}]}