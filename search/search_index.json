{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to llir/llvm Overview Why LLVM? When creating a compiler, a classical design may look like this: hierarchy Source Code Source Code Frontend Frontend Source Code->Frontend Optimizer Optimizer Frontend->Optimizer Backend Backend Optimizer->Backend Machine Code Machine Code Backend->Machine Code This worked quite well in the old days. There was only one input language, and one target machine. Today there exist a lot of target machines to support! And a lot of input languages. Without a shared representation many parts of the compiler would have to be reimplemented for every input/output pair. LLVM offers a solution to this problem by defining such a shared representation, namely LLVM IR. Here is the new design: hierarchy C Frontend C Frontend Optimizer Optimizer C Frontend->Optimizer Fortran Frontend Fortran Frontend Fortran Frontend->Optimizer Ada Frontend Ada Frontend Ada Frontend->Optimizer X86 Backend X86 Backend Optimizer->X86 Backend PowerPC Backend PowerPC Backend Optimizer->PowerPC Backend ARM Backend ARM Backend Optimizer->ARM Backend To write a compiler for a new language, now we only have to focus on our frontend. Similarly, to add support for a new target machine, now we only have to add a new backend. And to improve the code generation of all input/output pairs, now we only have to focus on the middle end optimizer. Thank you, Chris Lattner and all those who have contributed to LLVM. Why llir/llvm? The aim of llir/llvm is to provide a library for interacting with LLVM IR in pure Go. Importantly, llir/llvm is not a binding for LLVM. Therefore, you don't have to compile LLVM (which could take a few hours), and no need to fight with Cgo. Work under a pure Go environment and start your journey. Installation To install llir/llvm , all you need to do is: go get github.com/llir/llvm . Usage According to packages, llir/llvm can be separated into two main parts: asm : This package implements a parser for LLVM IR assembly files. Users can use it for analyzing LLVM IR files. ir : This package declares the types used to represent LLVM IR modules. Users can use it for build LLVM IR modules and operating on them.","title":"Home"},{"location":"#welcome-to-llirllvm","text":"","title":"Welcome to llir/llvm"},{"location":"#overview","text":"","title":"Overview"},{"location":"#why-llvm","text":"When creating a compiler, a classical design may look like this: hierarchy Source Code Source Code Frontend Frontend Source Code->Frontend Optimizer Optimizer Frontend->Optimizer Backend Backend Optimizer->Backend Machine Code Machine Code Backend->Machine Code This worked quite well in the old days. There was only one input language, and one target machine. Today there exist a lot of target machines to support! And a lot of input languages. Without a shared representation many parts of the compiler would have to be reimplemented for every input/output pair. LLVM offers a solution to this problem by defining such a shared representation, namely LLVM IR. Here is the new design: hierarchy C Frontend C Frontend Optimizer Optimizer C Frontend->Optimizer Fortran Frontend Fortran Frontend Fortran Frontend->Optimizer Ada Frontend Ada Frontend Ada Frontend->Optimizer X86 Backend X86 Backend Optimizer->X86 Backend PowerPC Backend PowerPC Backend Optimizer->PowerPC Backend ARM Backend ARM Backend Optimizer->ARM Backend To write a compiler for a new language, now we only have to focus on our frontend. Similarly, to add support for a new target machine, now we only have to add a new backend. And to improve the code generation of all input/output pairs, now we only have to focus on the middle end optimizer. Thank you, Chris Lattner and all those who have contributed to LLVM.","title":"Why LLVM?"},{"location":"#why-llirllvm","text":"The aim of llir/llvm is to provide a library for interacting with LLVM IR in pure Go. Importantly, llir/llvm is not a binding for LLVM. Therefore, you don't have to compile LLVM (which could take a few hours), and no need to fight with Cgo. Work under a pure Go environment and start your journey.","title":"Why llir/llvm?"},{"location":"#installation","text":"To install llir/llvm , all you need to do is: go get github.com/llir/llvm .","title":"Installation"},{"location":"#usage","text":"According to packages, llir/llvm can be separated into two main parts: asm : This package implements a parser for LLVM IR assembly files. Users can use it for analyzing LLVM IR files. ir : This package declares the types used to represent LLVM IR modules. Users can use it for build LLVM IR modules and operating on them.","title":"Usage"},{"location":"user-guide/basic/","text":"Basic Introduction Module An LLVM IR file is a module. A module has many top-level entities: global variables functions types metadata In this basic introduction, we won't dig into metadata, but instead focus on what we can do with global variables, functions, and types. llir/llvm provides package ir for these concepts. Let's see how a C program can be translated into LLVM IR using llir/llvm . C example: int g = 2; int add(int x, int y) { return x + y; } int main() { return add(1, g); } Generate module: package main import ( \"github.com/llir/llvm/ir\" \"github.com/llir/llvm/ir/constant\" \"github.com/llir/llvm/ir/types\" ) func main() { m := ir.NewModule() globalG := m.NewGlobalDef(\"g\", constant.NewInt(types.I32, 2)) funcAdd := m.NewFunc(\"add\", types.I32, ir.NewParam(\"x\", types.I32), ir.NewParam(\"y\", types.I32), ) ab := funcAdd.NewBlock(\"\") ab.NewRet(ab.NewAdd(funcAdd.Params[0], funcAdd.Params[1])) funcMain := m.NewFunc( \"main\", types.I32, ) // omit parameters mb := funcMain.NewBlock(\"\") // llir/llvm would give correct default name for block without name mb.NewRet(mb.NewCall(funcAdd, constant.NewInt(types.I32, 1), mb.NewLoad(types.I32, globalG))) println(m.String()) } Generated IR: @g = global i32 2 define i32 @add(i32 %x, i32 %y) { ; <label>:0 %1 = add i32 %x, %y ret i32 %1 } define i32 @main() { ; <label>:0 %1 = load i32, i32* @g %2 = call i32 @add(i32 1, i32 %1) ret i32 %2 } In this example, we have one global variable and two functions, mapping to C code. Now let's dig into global variables. Global Variable In LLVM IR assembly, the identifier of global variables are prefixed with an @ character. Importantly, global variables are represented in LLVM as pointers, so we have to use load to retreive the value and store to update the value of a global variable. Function Like globals, in LLVM IR assembly the identifier of functions are prefixed with an @ character. Functions are composed by a function prototype prototype and a group of basic blocks. A funciton without basic blocks is a function declaration. The following code would generate a function declaration: m.NewFunc( \"add\", types.I32, ir.NewParam(\"\", types.I32), ir.NewParam(\"\", types.I32), ) Output: declare i32 @add(i32, i32) When we want to bind to existing functions defined in other object files, we would create function declarations. Function Prototype A function prototype or function signature defines the parameters and return type of a function. Basic Block If function is group of basic blocks, then a basic block is a group of instructions. The basic notion behind a basic block is that if any instruction of a basic block is executed, then all instructions of the basic block are executed. In other words, there may be no branching or terminating instruction in the middle of a basic block, and all incoming branches must transfer control flow to the first instruction of the basic block. It is worthwhile to note that most high-level expression would be lowered into a set of instructions, covering one or more basic blocks. llir/llvm provides API to create instructions by a basic block. For further information, refer to the Block API documentation . Instruction An instruction is a set of operations on assembly abstraction level which operate on an abstract machine model, as defined by LLVM. For further information, refer to the Instruction Reference section of the LLVM Language Reference Manual . Type There are many types in LLVM type system, here we focus on how to create a new type. m := ir.NewModule() m.NewTypeDef(\"foo\", types.NewStruct(types.I32)) The above code would produce the following IR: %foo = type { i32 } Which could be mapped to the following C code: typedef struct { int x; } foo; Notice that in LLVM, structure fields have no name. Conclusion We hope that the previous sections have provide enough information about how to get use the documentation to dig into details. We will not dig into the details of each instruction; instead, we aim to provide a whole picture about how to use the library. Therefore, the next section is a list of common high-level concept and how to map them to IR.","title":"Basic Introduction"},{"location":"user-guide/basic/#basic-introduction","text":"","title":"Basic Introduction"},{"location":"user-guide/basic/#module","text":"An LLVM IR file is a module. A module has many top-level entities: global variables functions types metadata In this basic introduction, we won't dig into metadata, but instead focus on what we can do with global variables, functions, and types. llir/llvm provides package ir for these concepts. Let's see how a C program can be translated into LLVM IR using llir/llvm . C example: int g = 2; int add(int x, int y) { return x + y; } int main() { return add(1, g); } Generate module: package main import ( \"github.com/llir/llvm/ir\" \"github.com/llir/llvm/ir/constant\" \"github.com/llir/llvm/ir/types\" ) func main() { m := ir.NewModule() globalG := m.NewGlobalDef(\"g\", constant.NewInt(types.I32, 2)) funcAdd := m.NewFunc(\"add\", types.I32, ir.NewParam(\"x\", types.I32), ir.NewParam(\"y\", types.I32), ) ab := funcAdd.NewBlock(\"\") ab.NewRet(ab.NewAdd(funcAdd.Params[0], funcAdd.Params[1])) funcMain := m.NewFunc( \"main\", types.I32, ) // omit parameters mb := funcMain.NewBlock(\"\") // llir/llvm would give correct default name for block without name mb.NewRet(mb.NewCall(funcAdd, constant.NewInt(types.I32, 1), mb.NewLoad(types.I32, globalG))) println(m.String()) } Generated IR: @g = global i32 2 define i32 @add(i32 %x, i32 %y) { ; <label>:0 %1 = add i32 %x, %y ret i32 %1 } define i32 @main() { ; <label>:0 %1 = load i32, i32* @g %2 = call i32 @add(i32 1, i32 %1) ret i32 %2 } In this example, we have one global variable and two functions, mapping to C code. Now let's dig into global variables.","title":"Module"},{"location":"user-guide/basic/#global-variable","text":"In LLVM IR assembly, the identifier of global variables are prefixed with an @ character. Importantly, global variables are represented in LLVM as pointers, so we have to use load to retreive the value and store to update the value of a global variable.","title":"Global Variable"},{"location":"user-guide/basic/#function","text":"Like globals, in LLVM IR assembly the identifier of functions are prefixed with an @ character. Functions are composed by a function prototype prototype and a group of basic blocks. A funciton without basic blocks is a function declaration. The following code would generate a function declaration: m.NewFunc( \"add\", types.I32, ir.NewParam(\"\", types.I32), ir.NewParam(\"\", types.I32), ) Output: declare i32 @add(i32, i32) When we want to bind to existing functions defined in other object files, we would create function declarations.","title":"Function"},{"location":"user-guide/basic/#function-prototype","text":"A function prototype or function signature defines the parameters and return type of a function.","title":"Function Prototype"},{"location":"user-guide/basic/#basic-block","text":"If function is group of basic blocks, then a basic block is a group of instructions. The basic notion behind a basic block is that if any instruction of a basic block is executed, then all instructions of the basic block are executed. In other words, there may be no branching or terminating instruction in the middle of a basic block, and all incoming branches must transfer control flow to the first instruction of the basic block. It is worthwhile to note that most high-level expression would be lowered into a set of instructions, covering one or more basic blocks. llir/llvm provides API to create instructions by a basic block. For further information, refer to the Block API documentation .","title":"Basic Block"},{"location":"user-guide/basic/#instruction","text":"An instruction is a set of operations on assembly abstraction level which operate on an abstract machine model, as defined by LLVM. For further information, refer to the Instruction Reference section of the LLVM Language Reference Manual .","title":"Instruction"},{"location":"user-guide/basic/#type","text":"There are many types in LLVM type system, here we focus on how to create a new type. m := ir.NewModule() m.NewTypeDef(\"foo\", types.NewStruct(types.I32)) The above code would produce the following IR: %foo = type { i32 } Which could be mapped to the following C code: typedef struct { int x; } foo; Notice that in LLVM, structure fields have no name.","title":"Type"},{"location":"user-guide/basic/#conclusion","text":"We hope that the previous sections have provide enough information about how to get use the documentation to dig into details. We will not dig into the details of each instruction; instead, we aim to provide a whole picture about how to use the library. Therefore, the next section is a list of common high-level concept and how to map them to IR.","title":"Conclusion"},{"location":"user-guide/funcs/","text":"More Function Linkage The following code shows some linkage can use in IR. m := ir.NewModule() add := m.NewFunc(\"add\", types.I64, ir.NewParam(\"\", types.I64)) add.Linkage = enum.LinkageInternal add1 := m.NewFunc(\"add1\", types.I64, ir.NewParam(\"\", types.I64)) add1.Linkage = enum.LinkageLinkOnce add2 := m.NewFunc(\"add2\", types.I64, ir.NewParam(\"\", types.I64)) add2.Linkage = enum.LinkagePrivate add3 := m.NewFunc(\"add3\", types.I64, ir.NewParam(\"\", types.I64)) add3.Linkage = enum.LinkageWeak add4 := m.NewFunc(\"add4\", types.I64, ir.NewParam(\"\", types.I64)) add4.Linkage = enum.LinkageExternal The code would produce: declare internal i64 @add(i64) declare linkonce i64 @add1(i64) declare private i64 @add2(i64) declare weak i64 @add3(i64) declare external i64 @add4(i64) For further information about linkage, refer to LLVM doc and pkg.go.dev . Variant Argument (a.k.a. VAArg) One example of a variadic function is printf . This is how to create a function prototype for printf : m := ir.NewModule() printf := m.NewFunc( \"printf\", types.I32, ir.NewParam(\"\", types.NewPointer(types.I8)), ) printf.Sig.Variadic = true The above code would produce the following IR: declare i32 @printf(i8*, ...) Function Overloading There is no overloading in LLVM IR. One solution is to create one function per function signature, where each LLVM IR function would have a unique name (this is why C++ compilers do name mangling).","title":"More Function"},{"location":"user-guide/funcs/#more-function","text":"","title":"More Function"},{"location":"user-guide/funcs/#linkage","text":"The following code shows some linkage can use in IR. m := ir.NewModule() add := m.NewFunc(\"add\", types.I64, ir.NewParam(\"\", types.I64)) add.Linkage = enum.LinkageInternal add1 := m.NewFunc(\"add1\", types.I64, ir.NewParam(\"\", types.I64)) add1.Linkage = enum.LinkageLinkOnce add2 := m.NewFunc(\"add2\", types.I64, ir.NewParam(\"\", types.I64)) add2.Linkage = enum.LinkagePrivate add3 := m.NewFunc(\"add3\", types.I64, ir.NewParam(\"\", types.I64)) add3.Linkage = enum.LinkageWeak add4 := m.NewFunc(\"add4\", types.I64, ir.NewParam(\"\", types.I64)) add4.Linkage = enum.LinkageExternal The code would produce: declare internal i64 @add(i64) declare linkonce i64 @add1(i64) declare private i64 @add2(i64) declare weak i64 @add3(i64) declare external i64 @add4(i64) For further information about linkage, refer to LLVM doc and pkg.go.dev .","title":"Linkage"},{"location":"user-guide/funcs/#variant-argument-aka-vaarg","text":"One example of a variadic function is printf . This is how to create a function prototype for printf : m := ir.NewModule() printf := m.NewFunc( \"printf\", types.I32, ir.NewParam(\"\", types.NewPointer(types.I8)), ) printf.Sig.Variadic = true The above code would produce the following IR: declare i32 @printf(i8*, ...)","title":"Variant Argument (a.k.a. VAArg)"},{"location":"user-guide/funcs/#function-overloading","text":"There is no overloading in LLVM IR. One solution is to create one function per function signature, where each LLVM IR function would have a unique name (this is why C++ compilers do name mangling).","title":"Function Overloading"},{"location":"user-guide/types/","text":"High level types Structure Structure is quite common and basic type in programming language. Here focus on how to create an equal LLVM mapping for structure. LLVM has the concept about structure type, but structure type in LLVM didn't have field name, how to get/set fields of structure would be a thing. Let's assume a structure: foo has a field named x with type i32 . Below code shows how to access x . zero := constant.NewInt(types.I32, 0) m := ir.NewModule() foo := m.NewTypeDef(\"foo\", types.NewStruct(types.I32)) main := m.NewFunc(\"main\", types.I32) b := main.NewBlock(\"\") fooInstance := b.NewAlloca(foo) fieldX := b.NewGetElementPtr(foo, fooInstance, zero, zero) // now `fieldX` is a pointer to field `x` of `foo`. b.NewStore(constant.NewInt(types.I32, 10), fieldX) b.NewLoad(types.I32, fieldX) b.NewRet(zero) Get element pointer(a.k.a. GEP) is the point here. It computes a pointer to any structure member with no overhead. Then load and store can work on it. To get more information about GEP can goto Lang Ref . Algebra Data Type Algebra data type is a common concept in functional programming language. For example, Haskell can write: data Expr = EInt Int | EBool Bool | EString String How to express such concept in LLVM? The idea was selecting the biggest size in all variants and use it as the size of this type. Do bitcast when need to access the actual value. Here is the code: mod := ir.NewModule() typeExpr := mod.NewTypeDef(\"Expr\", types.NewStruct( types.I8, types.NewArray(8, types.I8), )) // variant tag 0 typeExprInt := mod.NewTypeDef(\"EInt\", types.NewStruct( types.I8, types.I32, )) // variant tag 1 mod.NewTypeDef(\"EBool\", types.NewStruct( types.I8, types.I1, )) // variant tag 2 mod.NewTypeDef(\"EString\", types.NewStruct( types.I8, types.NewPointer(types.I8), )) main := mod.NewFunc( \"main\", types.I32, ) b := main.NewBlock(\"\") exprInstance := b.NewAlloca(typeExpr) exprTag := b.NewGetElementPtr(typeExpr, exprInstance, constI32(0), constI32(0)) // set tag to 0 b.NewStore(constI8(0), exprTag) exprIntInstance := b.NewBitCast(exprInstance, types.NewPointer(typeExprInt)) exprIntValue := b.NewGetElementPtr(typeExprInt, exprIntInstance, constI32(0), constI32(1)) b.NewStore(constI32(2), exprIntValue) b.NewRet(constI32(0)) These code produce: %Expr = type { i8, [8 x i8] } %EInt = type { i8, i32 } %EBool = type { i8, i1 } %EString = type { i8, i8* } define i32 @main() { ; <label>:0 %1 = alloca %Expr %2 = getelementptr %Expr, %Expr* %1, i32 0, i32 0 store i8 0, i8* %2 %3 = bitcast %Expr* %1 to %EInt* %4 = getelementptr %EInt, %EInt* %3, i32 0, i32 1 store i32 2, i32* %4 ret i32 0 } tag in each variant is important, for example, pattern matching in Haskell looks like: case expr of EInt i -> \"int\" EBool b -> \"bool\" EString s -> \"string\" case expression would need tag to distinguish variant.","title":"High Level Types"},{"location":"user-guide/types/#high-level-types","text":"","title":"High level types"},{"location":"user-guide/types/#structure","text":"Structure is quite common and basic type in programming language. Here focus on how to create an equal LLVM mapping for structure. LLVM has the concept about structure type, but structure type in LLVM didn't have field name, how to get/set fields of structure would be a thing. Let's assume a structure: foo has a field named x with type i32 . Below code shows how to access x . zero := constant.NewInt(types.I32, 0) m := ir.NewModule() foo := m.NewTypeDef(\"foo\", types.NewStruct(types.I32)) main := m.NewFunc(\"main\", types.I32) b := main.NewBlock(\"\") fooInstance := b.NewAlloca(foo) fieldX := b.NewGetElementPtr(foo, fooInstance, zero, zero) // now `fieldX` is a pointer to field `x` of `foo`. b.NewStore(constant.NewInt(types.I32, 10), fieldX) b.NewLoad(types.I32, fieldX) b.NewRet(zero) Get element pointer(a.k.a. GEP) is the point here. It computes a pointer to any structure member with no overhead. Then load and store can work on it. To get more information about GEP can goto Lang Ref .","title":"Structure"},{"location":"user-guide/types/#algebra-data-type","text":"Algebra data type is a common concept in functional programming language. For example, Haskell can write: data Expr = EInt Int | EBool Bool | EString String How to express such concept in LLVM? The idea was selecting the biggest size in all variants and use it as the size of this type. Do bitcast when need to access the actual value. Here is the code: mod := ir.NewModule() typeExpr := mod.NewTypeDef(\"Expr\", types.NewStruct( types.I8, types.NewArray(8, types.I8), )) // variant tag 0 typeExprInt := mod.NewTypeDef(\"EInt\", types.NewStruct( types.I8, types.I32, )) // variant tag 1 mod.NewTypeDef(\"EBool\", types.NewStruct( types.I8, types.I1, )) // variant tag 2 mod.NewTypeDef(\"EString\", types.NewStruct( types.I8, types.NewPointer(types.I8), )) main := mod.NewFunc( \"main\", types.I32, ) b := main.NewBlock(\"\") exprInstance := b.NewAlloca(typeExpr) exprTag := b.NewGetElementPtr(typeExpr, exprInstance, constI32(0), constI32(0)) // set tag to 0 b.NewStore(constI8(0), exprTag) exprIntInstance := b.NewBitCast(exprInstance, types.NewPointer(typeExprInt)) exprIntValue := b.NewGetElementPtr(typeExprInt, exprIntInstance, constI32(0), constI32(1)) b.NewStore(constI32(2), exprIntValue) b.NewRet(constI32(0)) These code produce: %Expr = type { i8, [8 x i8] } %EInt = type { i8, i32 } %EBool = type { i8, i1 } %EString = type { i8, i8* } define i32 @main() { ; <label>:0 %1 = alloca %Expr %2 = getelementptr %Expr, %Expr* %1, i32 0, i32 0 store i8 0, i8* %2 %3 = bitcast %Expr* %1 to %EInt* %4 = getelementptr %EInt, %EInt* %3, i32 0, i32 1 store i32 2, i32* %4 ret i32 0 } tag in each variant is important, for example, pattern matching in Haskell looks like: case expr of EInt i -> \"int\" EBool b -> \"bool\" EString s -> \"string\" case expression would need tag to distinguish variant.","title":"Algebra Data Type"}]}