{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to llir/llvm Overview Why LLVM? When creating a compiler, a classical design looks like this: hierarchy Source Code Source Code Frontend Frontend Source Code->Frontend Optimizer Optimizer Frontend->Optimizer Backend Backend Optimizer->Backend Machine Code Machine Code Backend->Machine Code This is quite good in old days. There has only one input language, and one target machine. But there has more and more target machines have to support! Therefore, we need LLVM. Here is the new design: hierarchy C Frontend C Frontend Optimizer Optimizer C Frontend->Optimizer Fortran Frontend Fortran Frontend Fortran Frontend->Optimizer Ada Frontend Ada Frontend Ada Frontend->Optimizer X86 Backend X86 Backend Optimizer->X86 Backend PowerPC Backend PowerPC Backend Optimizer->PowerPC Backend ARM Backend ARM Backend Optimizer->ARM Backend Now we only have to focus on our frontend and optimizer! Thanks you, Chris Lattner and who had work for LLVM. Why llir/llvm? The target of llir/llvm is: interact in Go with LLVM IR without binding with LLVM. Therefore, you don't have to compile LLVM(could take few hours), no fighting with cgo. Working under pure Go environment and start your journey. Installation To install llir/llvm , all you need to do is: go get github.com/llir/llvm . Usage According to packages, llir/llvm can be separated to two main parts: asm : This package implements a parser for LLVM IR assembly files. Users can use it for analyzing LLVM IR files. ir : This package declares the types used to represent LLVM IR modules. Users can use it for build LLVM IR modules and operating on them.","title":"Home"},{"location":"#welcome-to-llirllvm","text":"","title":"Welcome to llir/llvm"},{"location":"#overview","text":"","title":"Overview"},{"location":"#why-llvm","text":"When creating a compiler, a classical design looks like this: hierarchy Source Code Source Code Frontend Frontend Source Code->Frontend Optimizer Optimizer Frontend->Optimizer Backend Backend Optimizer->Backend Machine Code Machine Code Backend->Machine Code This is quite good in old days. There has only one input language, and one target machine. But there has more and more target machines have to support! Therefore, we need LLVM. Here is the new design: hierarchy C Frontend C Frontend Optimizer Optimizer C Frontend->Optimizer Fortran Frontend Fortran Frontend Fortran Frontend->Optimizer Ada Frontend Ada Frontend Ada Frontend->Optimizer X86 Backend X86 Backend Optimizer->X86 Backend PowerPC Backend PowerPC Backend Optimizer->PowerPC Backend ARM Backend ARM Backend Optimizer->ARM Backend Now we only have to focus on our frontend and optimizer! Thanks you, Chris Lattner and who had work for LLVM.","title":"Why LLVM?"},{"location":"#why-llirllvm","text":"The target of llir/llvm is: interact in Go with LLVM IR without binding with LLVM. Therefore, you don't have to compile LLVM(could take few hours), no fighting with cgo. Working under pure Go environment and start your journey.","title":"Why llir/llvm?"},{"location":"#installation","text":"To install llir/llvm , all you need to do is: go get github.com/llir/llvm .","title":"Installation"},{"location":"#usage","text":"According to packages, llir/llvm can be separated to two main parts: asm : This package implements a parser for LLVM IR assembly files. Users can use it for analyzing LLVM IR files. ir : This package declares the types used to represent LLVM IR modules. Users can use it for build LLVM IR modules and operating on them.","title":"Usage"},{"location":"user-guide/basic/","text":"Basic Introduction Module A LLVM IR file is a module. A module owns many global level components: global variable function type metadata In this basic introduction, we don't dig into metadata, but focus on what can we do with global variable, function, and type. llir/llvm provides package ir for these concepts, let's see what can a C program being translated to LLVM IR using llir/llvm . C example: int g = 2; int add(int x, int y) { return x + y; } int main() { add(1, g); return 0; } Generate module: package main import ( \"github.com/llir/llvm/ir\" \"github.com/llir/llvm/ir/constant\" \"github.com/llir/llvm/ir/types\" ) func main() { m := ir.NewModule() globalG := m.NewGlobalDef(\"g\", constant.NewInt(types.I32, 2)) funcAdd := m.NewFunc(\"add\", types.I32, ir.NewParam(\"x\", types.I32), ir.NewParam(\"y\", types.I32), ) ab := funcAdd.NewBlock(\"\") ab.NewRet(ab.NewAdd(funcAdd.Params[0], funcAdd.Params[1])) funcMain := m.NewFunc( \"main\", types.I32, ) // omit parameters mb := funcMain.NewBlock(\"\") // llir/llvm would give correct default name for block without name mb.NewCall(funcAdd, constant.NewInt(types.I32, 1), mb.NewLoad(types.I32, globalG)) mb.NewRet(constant.NewInt(types.I32, 0)) println(m.String()) } Generated IR: @g = global i32 2 define i32 @add(i32 %x, i32 %y) { ; <label>:0 %1 = add i32 %x, %y ret i32 %1 } define i32 @main() { ; <label>:0 %1 = load i32, i32* @g %2 = call i32 @add(i32 1, i32 %1) ret i32 0 } In this example, we have global variable and function, mapping to C code. Now we dig into global variable. Global Variable Globals prefixed with @ character. An important thing is globals in LLVM, is a pointer, so have to load for its value, store to update its value. Function As globals, function name prefixed with @ character. Function composed by prototype and a group of basic blocks. If there has no basic block, then a function is a declaration, the following code would generate a declaration: m.NewFunc( \"add\", types.I32, ir.NewParam(\"\", types.I32), ir.NewParam(\"\", types.I32), ) Output: declare i32 @add(i32, i32) When we want to bind to existed function in others object files, we would create a declaration. Prototype Prototype means parameters and return type. Basic Block If function is group of basic blocks, then basic blocks is a group of instructions. An important thing is most high-level expression would break down into few instructions. llir/llvm provides API to create instructions by a basic block. To get more information, goto Block API document . Instruction Instruction is a set of operations on assembly abstraction level to operate on an abstract machine model. To get more information, goto LLVM Language Reference Manual: instruction reference . Type There are many types in LLVM type system, here focus on how to create a new type. m := ir.NewModule() m.NewTypeDef(\"foo\", types.NewStruct(types.I32)) Above code would produce: %foo = type { i32 } It could map to C code: struct foo { int x; }; Notice in LLVM, structure field has no name. Conclusion Hope previous sections provide enough information about how to get enough information to dig into details. We will not dig into the details of each instruction, instead of that, we would provide a whole picture about how to use the library. Therefore, the next section is a list of common high-level concept and how to map them to IR.","title":"Basic Introduction"},{"location":"user-guide/basic/#basic-introduction","text":"","title":"Basic Introduction"},{"location":"user-guide/basic/#module","text":"A LLVM IR file is a module. A module owns many global level components: global variable function type metadata In this basic introduction, we don't dig into metadata, but focus on what can we do with global variable, function, and type. llir/llvm provides package ir for these concepts, let's see what can a C program being translated to LLVM IR using llir/llvm . C example: int g = 2; int add(int x, int y) { return x + y; } int main() { add(1, g); return 0; } Generate module: package main import ( \"github.com/llir/llvm/ir\" \"github.com/llir/llvm/ir/constant\" \"github.com/llir/llvm/ir/types\" ) func main() { m := ir.NewModule() globalG := m.NewGlobalDef(\"g\", constant.NewInt(types.I32, 2)) funcAdd := m.NewFunc(\"add\", types.I32, ir.NewParam(\"x\", types.I32), ir.NewParam(\"y\", types.I32), ) ab := funcAdd.NewBlock(\"\") ab.NewRet(ab.NewAdd(funcAdd.Params[0], funcAdd.Params[1])) funcMain := m.NewFunc( \"main\", types.I32, ) // omit parameters mb := funcMain.NewBlock(\"\") // llir/llvm would give correct default name for block without name mb.NewCall(funcAdd, constant.NewInt(types.I32, 1), mb.NewLoad(types.I32, globalG)) mb.NewRet(constant.NewInt(types.I32, 0)) println(m.String()) } Generated IR: @g = global i32 2 define i32 @add(i32 %x, i32 %y) { ; <label>:0 %1 = add i32 %x, %y ret i32 %1 } define i32 @main() { ; <label>:0 %1 = load i32, i32* @g %2 = call i32 @add(i32 1, i32 %1) ret i32 0 } In this example, we have global variable and function, mapping to C code. Now we dig into global variable.","title":"Module"},{"location":"user-guide/basic/#global-variable","text":"Globals prefixed with @ character. An important thing is globals in LLVM, is a pointer, so have to load for its value, store to update its value.","title":"Global Variable"},{"location":"user-guide/basic/#function","text":"As globals, function name prefixed with @ character. Function composed by prototype and a group of basic blocks. If there has no basic block, then a function is a declaration, the following code would generate a declaration: m.NewFunc( \"add\", types.I32, ir.NewParam(\"\", types.I32), ir.NewParam(\"\", types.I32), ) Output: declare i32 @add(i32, i32) When we want to bind to existed function in others object files, we would create a declaration.","title":"Function"},{"location":"user-guide/basic/#prototype","text":"Prototype means parameters and return type.","title":"Prototype"},{"location":"user-guide/basic/#basic-block","text":"If function is group of basic blocks, then basic blocks is a group of instructions. An important thing is most high-level expression would break down into few instructions. llir/llvm provides API to create instructions by a basic block. To get more information, goto Block API document .","title":"Basic Block"},{"location":"user-guide/basic/#instruction","text":"Instruction is a set of operations on assembly abstraction level to operate on an abstract machine model. To get more information, goto LLVM Language Reference Manual: instruction reference .","title":"Instruction"},{"location":"user-guide/basic/#type","text":"There are many types in LLVM type system, here focus on how to create a new type. m := ir.NewModule() m.NewTypeDef(\"foo\", types.NewStruct(types.I32)) Above code would produce: %foo = type { i32 } It could map to C code: struct foo { int x; }; Notice in LLVM, structure field has no name.","title":"Type"},{"location":"user-guide/basic/#conclusion","text":"Hope previous sections provide enough information about how to get enough information to dig into details. We will not dig into the details of each instruction, instead of that, we would provide a whole picture about how to use the library. Therefore, the next section is a list of common high-level concept and how to map them to IR.","title":"Conclusion"},{"location":"user-guide/funcs/","text":"More Function Linkage The following code shows some linkage can use in IR. m := ir.NewModule() add := m.NewFunc(\"add\", types.I64, ir.NewParam(\"\", types.I64)) add.Linkage = enum.LinkageInternal add = m.NewFunc(\"add1\", types.I64, ir.NewParam(\"\", types.I64)) add.Linkage = enum.LinkageLinkOnce add = m.NewFunc(\"add2\", types.I64, ir.NewParam(\"\", types.I64)) add.Linkage = enum.LinkagePrivate add = m.NewFunc(\"add3\", types.I64, ir.NewParam(\"\", types.I64)) add.Linkage = enum.LinkageWeak add = m.NewFunc(\"add4\", types.I64, ir.NewParam(\"\", types.I64)) add.Linkage = enum.LinkageExternal The code would produce: declare internal i64 @add(i64) declare linkonce i64 @add1(i64) declare private i64 @add2(i64) declare weak i64 @add3(i64) declare external i64 @add4(i64) To get more information about linkage, read llvm doc and pkg.go.dev . Variant Argument(a.k.a. VAArg) One example is printf : m := ir.NewModule() printf := m.NewFunc( \"printf\", types.I32, ir.NewParam(\"\", types.NewPointer(types.I8)), ) printf.Sig.Variadic = true The code would produce: declare i32 @printf(i8*, ...) Function Overloading There has no overloading in IR, therefore solution is creating two functions.","title":"More Function"},{"location":"user-guide/funcs/#more-function","text":"","title":"More Function"},{"location":"user-guide/funcs/#linkage","text":"The following code shows some linkage can use in IR. m := ir.NewModule() add := m.NewFunc(\"add\", types.I64, ir.NewParam(\"\", types.I64)) add.Linkage = enum.LinkageInternal add = m.NewFunc(\"add1\", types.I64, ir.NewParam(\"\", types.I64)) add.Linkage = enum.LinkageLinkOnce add = m.NewFunc(\"add2\", types.I64, ir.NewParam(\"\", types.I64)) add.Linkage = enum.LinkagePrivate add = m.NewFunc(\"add3\", types.I64, ir.NewParam(\"\", types.I64)) add.Linkage = enum.LinkageWeak add = m.NewFunc(\"add4\", types.I64, ir.NewParam(\"\", types.I64)) add.Linkage = enum.LinkageExternal The code would produce: declare internal i64 @add(i64) declare linkonce i64 @add1(i64) declare private i64 @add2(i64) declare weak i64 @add3(i64) declare external i64 @add4(i64) To get more information about linkage, read llvm doc and pkg.go.dev .","title":"Linkage"},{"location":"user-guide/funcs/#variant-argumentaka-vaarg","text":"One example is printf : m := ir.NewModule() printf := m.NewFunc( \"printf\", types.I32, ir.NewParam(\"\", types.NewPointer(types.I8)), ) printf.Sig.Variadic = true The code would produce: declare i32 @printf(i8*, ...)","title":"Variant Argument(a.k.a. VAArg)"},{"location":"user-guide/funcs/#function-overloading","text":"There has no overloading in IR, therefore solution is creating two functions.","title":"Function Overloading"},{"location":"user-guide/types/","text":"High level types Structure Structure is quite common and basic type in programming language. Here focus on how to create an equal LLVM mapping for structure. LLVM has the concept about structure type, but structure type in LLVM didn't have field name, how to get/set fields of structure would be a thing. Let's assume a structure: foo has a field named x with type i32 . Below code shows how to access x . zero := constant.NewInt(types.I32, 0) m := ir.NewModule() foo := m.NewTypeDef(\"foo\", types.NewStruct(types.I32)) main := m.NewFunc(\"main\", types.I32) b := main.NewBlock(\"\") fooInstance := b.NewAlloca(foo) fieldX := b.NewGetElementPtr(foo, fooInstance, zero, zero) // now `fieldX` is a pointer to field `x` of `foo`. b.NewStore(constant.NewInt(types.I32, 10), fieldX) b.NewLoad(types.I32, fieldX) b.NewRet(zero) Get element pointer(a.k.a. GEP) is the point here. It computes a pointer to any structure member with no overhead. Then load and store can work on it. To get more information about GEP can goto Lang Ref . Algebra Data Type Algebra data type is a common concept in functional programming language. For example, Haskell can write: data Expr = EInt Int | EBool Bool | EString String How to express such concept in LLVM? The idea was selecting the biggest size in all variants and use it as the size of this type. Do bitcast when need to access the actual value. Here is the code: mod := ir.NewModule() typeExpr := mod.NewTypeDef(\"Expr\", types.NewStruct( types.I8, types.NewArray(8, types.I8), )) // variant tag 0 typeExprInt := mod.NewTypeDef(\"EInt\", types.NewStruct( types.I8, types.I32, )) // variant tag 1 mod.NewTypeDef(\"EBool\", types.NewStruct( types.I8, types.I1, )) // variant tag 2 mod.NewTypeDef(\"EString\", types.NewStruct( types.I8, types.NewPointer(types.I8), )) main := mod.NewFunc( \"main\", types.I32, ) b := main.NewBlock(\"\") exprInstance := b.NewAlloca(typeExpr) exprTag := b.NewGetElementPtr(typeExpr, exprInstance, constI32(0), constI32(0)) // set tag to 0 b.NewStore(constI8(0), exprTag) exprIntInstance := b.NewBitCast(exprInstance, types.NewPointer(typeExprInt)) exprIntValue := b.NewGetElementPtr(typeExprInt, exprIntInstance, constI32(0), constI32(1)) b.NewStore(constI32(2), exprIntValue) b.NewRet(constI32(0)) These code produce: %Expr = type { i8, [8 x i8] } %EInt = type { i8, i32 } %EBool = type { i8, i1 } %EString = type { i8, i8* } define i32 @main() { ; <label>:0 %1 = alloca %Expr %2 = getelementptr %Expr, %Expr* %1, i32 0, i32 0 store i8 0, i8* %2 %3 = bitcast %Expr* %1 to %EInt* %4 = getelementptr %EInt, %EInt* %3, i32 0, i32 1 store i32 2, i32* %4 ret i32 0 } tag in each variant is important, for example, pattern matching in Haskell looks like: case expr of EInt i -> \"int\" EBool b -> \"bool\" EString s -> \"string\" case expression would need tag to distinguish variant.","title":"High Level Types"},{"location":"user-guide/types/#high-level-types","text":"","title":"High level types"},{"location":"user-guide/types/#structure","text":"Structure is quite common and basic type in programming language. Here focus on how to create an equal LLVM mapping for structure. LLVM has the concept about structure type, but structure type in LLVM didn't have field name, how to get/set fields of structure would be a thing. Let's assume a structure: foo has a field named x with type i32 . Below code shows how to access x . zero := constant.NewInt(types.I32, 0) m := ir.NewModule() foo := m.NewTypeDef(\"foo\", types.NewStruct(types.I32)) main := m.NewFunc(\"main\", types.I32) b := main.NewBlock(\"\") fooInstance := b.NewAlloca(foo) fieldX := b.NewGetElementPtr(foo, fooInstance, zero, zero) // now `fieldX` is a pointer to field `x` of `foo`. b.NewStore(constant.NewInt(types.I32, 10), fieldX) b.NewLoad(types.I32, fieldX) b.NewRet(zero) Get element pointer(a.k.a. GEP) is the point here. It computes a pointer to any structure member with no overhead. Then load and store can work on it. To get more information about GEP can goto Lang Ref .","title":"Structure"},{"location":"user-guide/types/#algebra-data-type","text":"Algebra data type is a common concept in functional programming language. For example, Haskell can write: data Expr = EInt Int | EBool Bool | EString String How to express such concept in LLVM? The idea was selecting the biggest size in all variants and use it as the size of this type. Do bitcast when need to access the actual value. Here is the code: mod := ir.NewModule() typeExpr := mod.NewTypeDef(\"Expr\", types.NewStruct( types.I8, types.NewArray(8, types.I8), )) // variant tag 0 typeExprInt := mod.NewTypeDef(\"EInt\", types.NewStruct( types.I8, types.I32, )) // variant tag 1 mod.NewTypeDef(\"EBool\", types.NewStruct( types.I8, types.I1, )) // variant tag 2 mod.NewTypeDef(\"EString\", types.NewStruct( types.I8, types.NewPointer(types.I8), )) main := mod.NewFunc( \"main\", types.I32, ) b := main.NewBlock(\"\") exprInstance := b.NewAlloca(typeExpr) exprTag := b.NewGetElementPtr(typeExpr, exprInstance, constI32(0), constI32(0)) // set tag to 0 b.NewStore(constI8(0), exprTag) exprIntInstance := b.NewBitCast(exprInstance, types.NewPointer(typeExprInt)) exprIntValue := b.NewGetElementPtr(typeExprInt, exprIntInstance, constI32(0), constI32(1)) b.NewStore(constI32(2), exprIntValue) b.NewRet(constI32(0)) These code produce: %Expr = type { i8, [8 x i8] } %EInt = type { i8, i32 } %EBool = type { i8, i1 } %EString = type { i8, i8* } define i32 @main() { ; <label>:0 %1 = alloca %Expr %2 = getelementptr %Expr, %Expr* %1, i32 0, i32 0 store i8 0, i8* %2 %3 = bitcast %Expr* %1 to %EInt* %4 = getelementptr %EInt, %EInt* %3, i32 0, i32 1 store i32 2, i32* %4 ret i32 0 } tag in each variant is important, for example, pattern matching in Haskell looks like: case expr of EInt i -> \"int\" EBool b -> \"bool\" EString s -> \"string\" case expression would need tag to distinguish variant.","title":"Algebra Data Type"}]}