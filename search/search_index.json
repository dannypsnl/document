{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to llir/llvm Overview Why LLVM? When creating a compiler, a classical design looks like this: hierarchy Source Code Source Code Frontend Frontend Source Code->Frontend Optimizer Optimizer Frontend->Optimizer Backend Backend Optimizer->Backend Machine Code Machine Code Backend->Machine Code This is quite good in old days. There has only one input language, and one target machine. But there has more and more target machines have to support! Therefore, we need LLVM. Here is the new design: hierarchy C Frontend C Frontend Optimizer Optimizer C Frontend->Optimizer Fortran Frontend Fortran Frontend Fortran Frontend->Optimizer Ada Frontend Ada Frontend Ada Frontend->Optimizer X86 Backend X86 Backend Optimizer->X86 Backend PowerPC Backend PowerPC Backend Optimizer->PowerPC Backend ARM Backend ARM Backend Optimizer->ARM Backend Now we only have to focus on our frontend and optimizer! Thanks you, Chris Lattner and who had work for LLVM. Why llir/llvm? The target of llir/llvm is: interact in Go with LLVM IR without binding with LLVM. Therefore, you don't have to compile LLVM(could take few hours), no fighting with cgo. Working under pure Go environment and start your journey. Installation go get github.com/llir/llvm","title":"Welcome to llir/llvm"},{"location":"#welcome-to-llirllvm","text":"","title":"Welcome to llir/llvm"},{"location":"#overview","text":"","title":"Overview"},{"location":"#why-llvm","text":"When creating a compiler, a classical design looks like this: hierarchy Source Code Source Code Frontend Frontend Source Code->Frontend Optimizer Optimizer Frontend->Optimizer Backend Backend Optimizer->Backend Machine Code Machine Code Backend->Machine Code This is quite good in old days. There has only one input language, and one target machine. But there has more and more target machines have to support! Therefore, we need LLVM. Here is the new design: hierarchy C Frontend C Frontend Optimizer Optimizer C Frontend->Optimizer Fortran Frontend Fortran Frontend Fortran Frontend->Optimizer Ada Frontend Ada Frontend Ada Frontend->Optimizer X86 Backend X86 Backend Optimizer->X86 Backend PowerPC Backend PowerPC Backend Optimizer->PowerPC Backend ARM Backend ARM Backend Optimizer->ARM Backend Now we only have to focus on our frontend and optimizer! Thanks you, Chris Lattner and who had work for LLVM.","title":"Why LLVM?"},{"location":"#why-llirllvm","text":"The target of llir/llvm is: interact in Go with LLVM IR without binding with LLVM. Therefore, you don't have to compile LLVM(could take few hours), no fighting with cgo. Working under pure Go environment and start your journey.","title":"Why llir/llvm?"},{"location":"#installation","text":"go get github.com/llir/llvm","title":"Installation"}]}